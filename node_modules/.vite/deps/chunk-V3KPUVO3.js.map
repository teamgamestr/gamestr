{
  "version": 3,
  "sources": ["../../@nostrify/nostrify/dist/BunkerURI.js", "../../@nostrify/nostrify/dist/NBrowserSigner.js", "../../lru-cache/src/index.ts", "../../@nostrify/nostrify/dist/NSet.js", "../../@nostrify/nostrify/dist/NCache.js", "../../@nostrify/nostrify/dist/NConnectSigner.js", "../../@nostrify/nostrify/dist/NIP05.js", "../../@nostrify/nostrify/dist/NIP50.js", "../../@nostrify/nostrify/dist/NIP98Client.js", "../../@nostrify/nostrify/dist/NKinds.js", "../../@nostrify/nostrify/dist/utils/CircularSet.js", "../../@nostrify/nostrify/dist/utils/Machina.js", "../../@nostrify/nostrify/dist/NPool.js", "../../websocket-ts/src/backoff/exponentialbackoff.ts", "../../websocket-ts/src/queue/array_queue.ts", "../../websocket-ts/src/websocket_event.ts", "../../websocket-ts/src/websocket.ts", "../../websocket-ts/src/websocket_builder.ts", "../../@nostrify/nostrify/dist/NRelay1.js", "../../@nostrify/nostrify/dist/NSecSigner.js", "../../@nostrify/nostrify/dist/RelayError.js"],
  "sourcesContent": ["class BunkerURI {\n  /** Remote signer pubkey. */\n  pubkey;\n  /** Relay URLs on which the client is listening for responses from the remote-signer. */\n  relays;\n  /** A short random string that the remote-signer should return as the `result` field of its response. */\n  secret;\n  constructor(uri) {\n    const url = new URL(uri);\n    const params = new URLSearchParams(url.search);\n    const pubkey = url.hostname || url.pathname.slice(2);\n    const relays = params.getAll(\"relay\");\n    const secret = params.get(\"secret\") ?? void 0;\n    if (!pubkey) {\n      throw new Error(\"Invalid bunker URI\");\n    }\n    this.pubkey = pubkey;\n    this.relays = relays;\n    this.secret = secret;\n  }\n  /** Convert into a `bunker://` URI string. */\n  get href() {\n    return this.toString();\n  }\n  /** Convert into a `bunker://` URI string. */\n  toString() {\n    return BunkerURI.toString(this);\n  }\n  /** Convert a bunker data object into a `BunkerURI` instance. */\n  static fromJSON(data) {\n    const uri = BunkerURI.toString(data);\n    return new BunkerURI(uri);\n  }\n  /** Convert a bunker data object into a bunker URI string. */\n  static toString(data) {\n    const search = new URLSearchParams();\n    for (const relay of data.relays) {\n      search.append(\"relay\", relay);\n    }\n    if (data.secret) {\n      search.set(\"secret\", data.secret);\n    }\n    return `bunker://${data.pubkey}?${search.toString()}`;\n  }\n}\nexport {\n  BunkerURI\n};\n", "class NBrowserSigner {\n  get nostr() {\n    const nostr = globalThis.nostr;\n    if (!nostr) {\n      throw new Error(\"Browser extension not available\");\n    }\n    return nostr;\n  }\n  async getPublicKey() {\n    const pubkey = await this.nostr.getPublicKey();\n    if (typeof pubkey !== \"string\") {\n      throw new Error(`Nostr public key retrieval failed: expected string, got ${JSON.stringify(pubkey)}`);\n    }\n    return pubkey;\n  }\n  async signEvent(event) {\n    const signed = await this.nostr.signEvent(event);\n    if (typeof signed !== \"object\" || !signed.id || !signed.pubkey || !signed.sig) {\n      throw new Error(\n        `Nostr event signing failed: expected object with id, pubkey, and sig, got ${JSON.stringify(signed)}`\n      );\n    }\n    return signed;\n  }\n  async getRelays() {\n    if (!this.nostr.getRelays) {\n      return {};\n    }\n    const relays = await this.nostr.getRelays();\n    if (typeof relays !== \"object\" || relays === null) {\n      throw new Error(`Nostr getRelays failed: expected object, got ${JSON.stringify(relays)}`);\n    }\n    return this.nostr.getRelays();\n  }\n  get nip04() {\n    const nostr = this.nostr;\n    if (!nostr.nip04) {\n      return void 0;\n    }\n    return {\n      encrypt: async (pubkey, plaintext) => {\n        const encrypted = await nostr.nip04.encrypt(pubkey, plaintext);\n        if (typeof encrypted !== \"string\") {\n          throw new Error(`NIP-04 encryption failed: expected string result, got ${JSON.stringify(encrypted)}`);\n        }\n        return encrypted;\n      },\n      decrypt: async (pubkey, ciphertext) => {\n        const decrypted = await nostr.nip04.decrypt(pubkey, ciphertext);\n        if (typeof decrypted !== \"string\") {\n          throw new Error(`NIP-04 decryption failed: expected string result, got ${JSON.stringify(decrypted)}`);\n        }\n        return decrypted;\n      }\n    };\n  }\n  get nip44() {\n    const nostr = this.nostr;\n    if (!nostr.nip44) {\n      return void 0;\n    }\n    return {\n      encrypt: async (pubkey, plaintext) => {\n        const encrypted = await nostr.nip44.encrypt(pubkey, plaintext);\n        if (typeof encrypted !== \"string\") {\n          throw new Error(`NIP-44 encryption failed: expected string result, got ${JSON.stringify(encrypted)}`);\n        }\n        return encrypted;\n      },\n      decrypt: async (pubkey, ciphertext) => {\n        const decrypted = await nostr.nip44.decrypt(pubkey, ciphertext);\n        if (typeof decrypted !== \"string\") {\n          throw new Error(`NIP-44 decryption failed: expected string result, got ${JSON.stringify(decrypted)}`);\n        }\n        return decrypted;\n      }\n    };\n  }\n}\nexport {\n  NBrowserSigner\n};\n", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "class NSet {\n  cache;\n  constructor(map) {\n    this.cache = map ?? /* @__PURE__ */ new Map();\n  }\n  get size() {\n    return this.cache.size;\n  }\n  add(event) {\n    this.#processDeletions(event);\n    for (const e of this) {\n      if (NSet.deletes(e, event) || NSet.replaces(e, event)) {\n        return this;\n      } else if (NSet.replaces(event, e)) {\n        this.delete(e);\n      }\n    }\n    this.cache.set(event.id, event);\n    return this;\n  }\n  #processDeletions(event) {\n    if (event.kind === 5) {\n      for (const tag of event.tags) {\n        if (tag[0] === \"e\") {\n          const e = this.cache.get(tag[1]);\n          if (e && e.pubkey === event.pubkey) {\n            this.delete(e);\n          }\n        }\n      }\n    }\n  }\n  clear() {\n    this.cache.clear();\n  }\n  delete(event) {\n    return this.cache.delete(event.id);\n  }\n  forEach(callbackfn, thisArg) {\n    return this.cache.forEach(\n      (event, _id) => callbackfn(event, event, this),\n      thisArg\n    );\n  }\n  has(event) {\n    return this.cache.has(event.id);\n  }\n  *entries() {\n    for (const event of this.values()) {\n      yield [event, event];\n    }\n  }\n  keys() {\n    return this.values();\n  }\n  *values() {\n    for (const event of NSet.sortEvents([...this.cache.values()])) {\n      yield event;\n    }\n  }\n  [Symbol.iterator]() {\n    return this.values();\n  }\n  [Symbol.toStringTag] = \"NSet\";\n  /** Event kind is **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */\n  static isReplaceable(kind) {\n    return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n  }\n  /** Event kind is **parameterized replaceable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */\n  static isAddressable(kind) {\n    return 3e4 <= kind && kind < 4e4;\n  }\n  /**\n   * Returns true if `event` replaces `target`.\n   *\n   * Both events must be replaceable, belong to the same kind and pubkey (and `d` tag, for parameterized events), and the `event` must be newer than the `target`.\n   */\n  static replaces(event, target) {\n    const { kind, pubkey } = event;\n    if (NSet.isReplaceable(kind)) {\n      return kind === target.kind && pubkey === target.pubkey && NSet.sortEvents([event, target])[0] === event;\n    }\n    if (NSet.isAddressable(kind)) {\n      const d1 = event.tags.find(([name]) => name === \"d\")?.[1] || \"\";\n      const d2 = target.tags.find(([name]) => name === \"d\")?.[1] || \"\";\n      return kind === target.kind && pubkey === target.pubkey && NSet.sortEvents([event, target])[0] === event && d1 === d2;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the `event` deletes`target`.\n   *\n   * `event` must be a kind `5` event, and both events must share the same `pubkey`.\n   */\n  static deletes(event, target) {\n    const { kind, pubkey, tags } = event;\n    if (kind === 5 && pubkey === target.pubkey) {\n      for (const [name, value] of tags) {\n        if (name === \"e\" && value === target.id) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Sort events in reverse-chronological order by the `created_at` timestamp,\n   * and then by the event `id` (lexicographically) in case of ties.\n   * This mutates the array.\n   */\n  static sortEvents(events) {\n    return events.sort((a, b) => {\n      if (a.created_at !== b.created_at) {\n        return b.created_at - a.created_at;\n      }\n      return a.id.localeCompare(b.id);\n    });\n  }\n  union(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n  intersection(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n  difference(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n  symmetricDifference(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n  isSubsetOf(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n  isSupersetOf(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n  isDisjointFrom(_other) {\n    throw new Error(\"Method not implemented.\");\n  }\n}\nexport {\n  NSet\n};\n", "import { LRUCache } from \"lru-cache\";\nimport { matchFilters } from \"nostr-tools\";\nimport { NSet } from \"./NSet.js\";\nclass NCache extends NSet {\n  constructor(...args) {\n    super(new LRUCache(...args));\n  }\n  async event(event) {\n    this.add(event);\n  }\n  async query(filters) {\n    const events = [];\n    for (const event of this) {\n      if (matchFilters(filters, event)) {\n        this.cache.get(event.id);\n        events.push(event);\n      }\n    }\n    return events;\n  }\n  async remove(filters) {\n    for (const event of this) {\n      if (matchFilters(filters, event)) {\n        this.delete(event);\n      }\n    }\n  }\n  async count(filters) {\n    const events = await this.query(filters);\n    return {\n      count: events.length,\n      approximate: false\n    };\n  }\n  [Symbol.toStringTag] = \"NCache\";\n}\nexport {\n  NCache\n};\n", "import { z } from \"zod\";\nimport { NSchema as n } from \"./NSchema.js\";\nclass NConnectSigner {\n  relay;\n  pubkey;\n  signer;\n  timeout;\n  encryption;\n  constructor({ relay, pubkey, signer, timeout, encryption = \"nip44\" }) {\n    this.relay = relay;\n    this.pubkey = pubkey;\n    this.signer = signer;\n    this.timeout = timeout;\n    this.encryption = encryption;\n  }\n  async getPublicKey() {\n    return this.cmd(\"get_public_key\", []);\n  }\n  async signEvent(event) {\n    const result = await this.cmd(\"sign_event\", [JSON.stringify(event)]);\n    return n.json().pipe(n.event()).parse(result);\n  }\n  async getRelays() {\n    const result = await this.cmd(\"get_relays\", []);\n    return n.json().pipe(\n      z.record(\n        z.string(),\n        z.object({ read: z.boolean(), write: z.boolean() })\n      )\n    ).parse(result);\n  }\n  nip04 = {\n    encrypt: async (pubkey, plaintext) => {\n      return this.cmd(\"nip04_encrypt\", [pubkey, plaintext]);\n    },\n    decrypt: async (pubkey, ciphertext) => {\n      return this.cmd(\"nip04_decrypt\", [pubkey, ciphertext]);\n    }\n  };\n  nip44 = {\n    encrypt: async (pubkey, plaintext) => {\n      return this.cmd(\"nip44_encrypt\", [pubkey, plaintext]);\n    },\n    decrypt: async (pubkey, ciphertext) => {\n      return this.cmd(\"nip44_decrypt\", [pubkey, ciphertext]);\n    }\n  };\n  /** Send a `connect` command to the relay. It should respond with `ack`. */\n  async connect(secret) {\n    const params = [this.pubkey];\n    if (secret) {\n      params.push(secret);\n    }\n    return this.cmd(\"connect\", params);\n  }\n  /** Send a `ping` command to the signer. It should respond with `pong`. */\n  async ping() {\n    return this.cmd(\"ping\", []);\n  }\n  /** High-level RPC method. Returns the string result, or throws on error. */\n  async cmd(method, params) {\n    const signal = typeof this.timeout === \"number\" ? AbortSignal.timeout(this.timeout) : void 0;\n    const { result, error } = await this.send(\n      { id: crypto.randomUUID(), method, params },\n      { signal }\n    );\n    if (error) {\n      throw new Error(error);\n    }\n    return result;\n  }\n  /** Low-level send method. Deals directly with connect request/response. */\n  async send(request, opts = {}) {\n    const { signal } = opts;\n    const event = await this.signer.signEvent({\n      kind: 24133,\n      content: await this.encrypt(this.pubkey, JSON.stringify(request)),\n      created_at: Math.floor(Date.now() / 1e3),\n      tags: [[\"p\", this.pubkey]]\n    });\n    const local = await this.signer.getPublicKey();\n    const req = this.relay.req(\n      [{ kinds: [24133], authors: [this.pubkey], \"#p\": [local] }],\n      { signal }\n    );\n    const promise = new Promise((resolve, reject) => {\n      (async () => {\n        try {\n          for await (const msg of req) {\n            if (msg[0] === \"CLOSED\") throw new Error(\"Subscription closed\");\n            if (msg[0] === \"EVENT\") {\n              const event2 = msg[2];\n              const decrypted = await this.decrypt(this.pubkey, event2.content);\n              const response = n.json().pipe(n.connectResponse()).parse(\n                decrypted\n              );\n              if (response.id === request.id) {\n                resolve(response);\n                return;\n              }\n            }\n          }\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n    await this.relay.event(event, { signal });\n    return promise;\n  }\n  /** Local encrypt depending on settings. */\n  async encrypt(pubkey, plaintext) {\n    switch (this.encryption) {\n      case \"nip04\":\n        return this.signer.nip04.encrypt(pubkey, plaintext);\n      case \"nip44\":\n        return this.signer.nip44.encrypt(pubkey, plaintext);\n    }\n  }\n  /** Local decrypt depending on settings. */\n  async decrypt(pubkey, ciphertext) {\n    switch (this.encryption) {\n      case \"nip04\":\n        return this.signer.nip04.decrypt(pubkey, ciphertext);\n      case \"nip44\":\n        return this.signer.nip44.decrypt(pubkey, ciphertext);\n    }\n  }\n}\nexport {\n  NConnectSigner\n};\n", "import { NSchema as n, z } from \"./NSchema.js\";\nclass NIP05 {\n  /** NIP-05 value regex. */\n  static regex() {\n    return /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\n  }\n  /** Nostr pubkey with relays object. */\n  static profilePointerSchema() {\n    return z.object({\n      pubkey: n.id(),\n      relays: n.relayUrl().array().optional()\n    });\n  }\n  /** Resolve NIP-05 name to a profile pointer. */\n  static async lookup(nip05, opts) {\n    const { fetch = globalThis.fetch.bind(globalThis), signal } = opts ?? {};\n    const match = nip05.match(NIP05.regex());\n    if (!match) throw new Error(`NIP-05: invalid name ${nip05}`);\n    const [_, name = \"_\", domain] = match;\n    const url = new URL(\"/.well-known/nostr.json\", `https://${domain}/`);\n    url.searchParams.set(\"name\", name);\n    const response = await fetch(url, { signal });\n    const json = await response.json();\n    try {\n      const pubkey = json.names[name];\n      const relays = json.relays?.[pubkey];\n      return NIP05.profilePointerSchema().parse({ pubkey, relays });\n    } catch {\n      throw new Error(`NIP-05: no match for ${nip05}`);\n    }\n  }\n}\nexport {\n  NIP05\n};\n", "class NIP50 {\n  static parseInput(input) {\n    const regex = /(\\B-\\w+:[^\\s\"]+)|(\\b\\w+:[^\\s\"]+)|(\".*?\")|(\\S+)/g;\n    const tokens = [];\n    let match;\n    while ((match = regex.exec(input)) !== null) {\n      if (match[1] || match[2]) {\n        const [key, ...values] = (match[1] || match[2]).split(\":\");\n        tokens.push({ key, value: values.join(\":\") });\n      } else if (match[3]) {\n        tokens.push(match[3].replace(/\"/g, \"\"));\n      } else if (match[4]) {\n        tokens.push(match[4]);\n      }\n    }\n    return tokens;\n  }\n}\nexport {\n  NIP50\n};\n", "import { NIP98 } from \"./NIP98.js\";\nimport { N64 } from \"./utils/N64.js\";\nclass NIP98Client {\n  signer;\n  customFetch;\n  constructor(opts) {\n    this.signer = opts.signer;\n    this.customFetch = opts.fetch ?? globalThis.fetch.bind(globalThis);\n  }\n  /** Performs a fetch request with NIP98 authentication */\n  async fetch(input, init) {\n    const request = new Request(input, init);\n    const template = await NIP98.template(request);\n    const event = await this.signer.signEvent(template);\n    const token = N64.encodeEvent(event);\n    request.headers.set(\"Authorization\", `Nostr ${token}`);\n    return this.customFetch(request);\n  }\n}\nexport {\n  NIP98Client\n};\n", "class NKinds {\n  /** Events are **regular**, which means they're all expected to be stored by relays. */\n  static regular(kind) {\n    return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n  }\n  /** Events are **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */\n  static replaceable(kind) {\n    return 1e4 <= kind && kind < 2e4 || [0, 3].includes(kind);\n  }\n  /** Events are **ephemeral**, which means they are not expected to be stored by relays. */\n  static ephemeral(kind) {\n    return 2e4 <= kind && kind < 3e4;\n  }\n  /** Events are **addressable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */\n  static addressable(kind) {\n    return 3e4 <= kind && kind < 4e4;\n  }\n  /** @deprecated Use `NKinds.addressable()` instead. */\n  static parameterizedReplaceable(kind) {\n    return NKinds.addressable(kind);\n  }\n}\nexport {\n  NKinds\n};\n", "class CircularSet {\n  set;\n  capacity;\n  constructor(capacity) {\n    this.set = /* @__PURE__ */ new Set();\n    this.capacity = capacity;\n  }\n  add(item) {\n    if (this.set.has(item)) {\n      return;\n    }\n    if (this.set.size >= this.capacity) {\n      const oldest = this.set.values().next().value;\n      if (oldest) {\n        this.set.delete(oldest);\n      }\n    }\n    this.set.add(item);\n  }\n  has(item) {\n    return this.set.has(item);\n  }\n  [Symbol.iterator]() {\n    return this.set.values();\n  }\n}\nexport {\n  CircularSet\n};\n", "class Machina {\n  #queue = [];\n  #resolve;\n  #aborted = false;\n  constructor(signal) {\n    if (signal?.aborted) {\n      this.abort();\n    } else {\n      signal?.addEventListener(\"abort\", () => this.abort(), { once: true });\n    }\n  }\n  /** Get messages as an AsyncIterable. */\n  async *[Symbol.asyncIterator]() {\n    while (!this.#aborted) {\n      if (this.#queue.length) {\n        yield this.#queue.shift();\n        continue;\n      }\n      await new Promise((_resolve) => {\n        this.#resolve = _resolve;\n      });\n    }\n    throw new DOMException(\"The signal has been aborted\", \"AbortError\");\n  }\n  /** Push a message into the Machina instance, making it available to the consumer of `stream()`. */\n  push(data) {\n    this.#queue.push(data);\n    this.#resolve?.();\n  }\n  /** Stops streaming and throws an error to the consumer. */\n  abort() {\n    this.#aborted = true;\n    this.#resolve?.();\n  }\n}\nexport {\n  Machina\n};\n", "import { getFilterLimit } from \"nostr-tools\";\nimport { CircularSet } from \"./utils/CircularSet.js\";\nimport { Machina } from \"./utils/Machina.js\";\nimport { NSet } from \"./NSet.js\";\nclass NPool {\n  _relays = /* @__PURE__ */ new Map();\n  opts;\n  constructor(opts) {\n    this.opts = opts;\n  }\n  /** Get or create a relay instance for the given URL. */\n  relay(url) {\n    const relay = this._relays.get(url);\n    if (relay) {\n      return relay;\n    } else {\n      const relay2 = this.opts.open(url);\n      this._relays.set(url, relay2);\n      return relay2;\n    }\n  }\n  /** Returns a new pool instance that uses the given relays. Connections are shared with the original pool. */\n  group(urls) {\n    return new NPool({\n      open: (url) => this.relay(url),\n      reqRouter: (filters) => new Map(urls.map((url) => [url, filters])),\n      eventRouter: () => urls\n    });\n  }\n  get relays() {\n    return this._relays;\n  }\n  /**\n   * Sends a `REQ` to relays based on the configured `reqRouter`.\n   *\n   * `EVENT` messages from the selected relays are yielded.\n   * `EOSE` and `CLOSE` messages are only yielded when all relays have emitted them.\n   *\n   * Deduplication of `EVENT` messages is attempted, so that each event is only yielded once.\n   * A circular set of 1000 is used to track seen event IDs, so it's possible that very\n   * long-running subscriptions (with over 1000 results) may yield duplicate events.\n   */\n  async *req(filters, opts) {\n    const controller = new AbortController();\n    const signal = opts?.signal ? AbortSignal.any([opts.signal, controller.signal]) : controller.signal;\n    const routes = opts?.relays ? new Map(opts.relays.map((url) => [url, filters])) : await this.opts.reqRouter(filters);\n    if (routes.size < 1) {\n      return;\n    }\n    const machina = new Machina(signal);\n    const eoses = /* @__PURE__ */ new Set();\n    const closes = /* @__PURE__ */ new Set();\n    const events = new CircularSet(1e3);\n    const relayPromises = [];\n    for (const [url, filters2] of routes.entries()) {\n      const relay = this.relay(url);\n      const relayPromise = (async () => {\n        try {\n          for await (const msg of relay.req(filters2, { signal })) {\n            if (msg[0] === \"EOSE\") {\n              eoses.add(url);\n              if (eoses.size === routes.size) {\n                machina.push(msg);\n              }\n            }\n            if (msg[0] === \"CLOSED\") {\n              closes.add(url);\n              if (closes.size === routes.size) {\n                machina.push(msg);\n              }\n            }\n            if (msg[0] === \"EVENT\") {\n              const [, , event] = msg;\n              if (!events.has(event.id)) {\n                events.add(event.id);\n                machina.push(msg);\n              }\n            }\n          }\n        } catch {\n        }\n      })();\n      relayPromises.push(relayPromise);\n    }\n    try {\n      for await (const msg of machina) {\n        yield msg;\n      }\n    } finally {\n      controller.abort();\n      await Promise.allSettled(relayPromises);\n    }\n  }\n  /**\n   * Events are sent to relays according to the `eventRouter`.\n   * Returns a fulfilled promise if ANY relay accepted the event,\n   * or a rejected promise if ALL relays rejected or failed to publish the event.\n   */\n  async event(event, opts) {\n    const relayUrls = opts?.relays ?? await this.opts.eventRouter(event);\n    if (!relayUrls.length) {\n      return;\n    }\n    await Promise.any(\n      relayUrls.map((url) => this.relay(url).event(event, opts))\n    );\n  }\n  /**\n   * This method calls `.req` internally and then post-processes the results.\n   * Please read the definition of `.req`.\n   *\n   * - The strategy is to seek regular events quickly, and to wait to find the latest versions of replaceable events.\n   * - Filters for replaceable events will wait for all relays to `EOSE` (or `CLOSE`, or for the signal to be aborted) to ensure the latest event versions are retrieved.\n   * - Filters for regular events will stop as soon as the filters are fulfilled.\n   * - Events are deduplicated, sorted, and only the latest version of replaceable events is kept.\n   * - If the signal is aborted, this method will return partial results instead of throwing.\n   *\n   * To implement a custom strategy, call `.req` directly.\n   */\n  async query(filters, opts) {\n    const map = /* @__PURE__ */ new Map();\n    const events = new NSet(map);\n    const limit = filters.reduce(\n      (result, filter) => result + getFilterLimit(filter),\n      0\n    );\n    if (limit === 0) return [];\n    try {\n      for await (const msg of this.req(filters, opts)) {\n        if (msg[0] === \"EOSE\") break;\n        if (msg[0] === \"EVENT\") events.add(msg[2]);\n        if (msg[0] === \"CLOSED\") break;\n      }\n    } catch {\n    }\n    if (filters.some((filter) => typeof filter.search === \"string\")) {\n      return [...map.values()];\n    } else {\n      return [...events];\n    }\n  }\n  /** Close all the relays in the pool. */\n  async close() {\n    await Promise.all(\n      [...this._relays.values()].map((relay) => relay.close())\n    );\n  }\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n}\nexport {\n  NPool\n};\n", "import { Backoff } from \"./backoff\";\n\n/**\n * ExponentialBackoff increases the backoff-time exponentially.\n * An optional maximum can be provided as an upper bound to the\n * exponent and thus to the returned backoff.\n *\n * The series can be described as ('i' is the current step/retry):\n *    backoff = base * 2^i                | without bound\n *    backoff = base * 2^min(i, expMax)   | with bound\n *\n * Example:\n *\n * 1) Without bound:\n *   base = 1000, expMax = undefined\n *   backoff = 1000 * 2^0 = 1000 // first retry\n *   backoff = 1000 * 2^1 = 2000 // second retry\n *   backoff = 1000 * 2^2 = 4000 // ...doubles with every retry\n *   backoff = 1000 * 2^3 = 8000\n *   backoff = 1000 * 2^4 = 16000\n *   ... // and so on\n *\n * 2) With bound:\n *  base = 1000, expMax = 3\n *  backoff = 1000 * 2^0 = 1000 // first retry\n *  backoff = 1000 * 2^1 = 2000 // second retry\n *  backoff = 1000 * 2^2 = 4000 // third retry\n *  backoff = 1000 * 2^3 = 8000 // maximum reached, don't increase further\n *  backoff = 1000 * 2^3 = 8000\n *  backoff = 1000 * 2^3 = 8000\n *  ... // and so on\n */\nexport class ExponentialBackoff implements Backoff {\n  private readonly base: number;\n  private readonly expMax?: number;\n  private i: number;\n  private _retries: number = 0;\n\n  /**\n   * Creates a new ExponentialBackoff.\n   * @param base the base of the exponentiation\n   * @param expMax the maximum exponent, no bound if undefined\n   */\n  constructor(base: number, expMax?: number) {\n    if (!Number.isInteger(base) || base < 0) {\n      throw new Error(\"Base must be a positive integer or zero\");\n    }\n    if (expMax !== undefined && (!Number.isInteger(expMax) || expMax < 0)) {\n      throw new Error(\"ExpMax must be a undefined, a positive integer or zero\");\n    }\n\n    this.base = base;\n    this.expMax = expMax;\n    this.i = 0;\n  }\n\n  get retries() {\n    return this._retries;\n  }\n\n  get current(): number {\n    return this.base * Math.pow(2, this.i);\n  }\n\n  next(): number {\n    this._retries++;\n    this.i =\n      this.expMax === undefined\n        ? this.i + 1\n        : Math.min(this.i + 1, this.expMax);\n    return this.current;\n  }\n\n  reset(): void {\n    this._retries = 0;\n    this.i = 0;\n  }\n}\n", "import { Queue } from \"./queue\";\n\n/**\n * An array queue is a queue that has an unbounded capacity. Reading from an array queue\n * will return the oldest element and effectively remove it from the queue.\n */\nexport class ArrayQueue<E> implements Queue<E> {\n  private readonly elements: E[];\n\n  constructor() {\n    this.elements = [];\n  }\n\n  add(element: E): void {\n    this.elements.push(element);\n  }\n\n  clear() {\n    this.elements.length = 0;\n  }\n\n  forEach(fn: (element: E) => unknown) {\n    this.elements.forEach(fn);\n  }\n\n  length(): number {\n    return this.elements.length;\n  }\n\n  isEmpty(): boolean {\n    return this.elements.length === 0;\n  }\n\n  peek(): E | undefined {\n    return this.elements[0];\n  }\n\n  read(): E | undefined {\n    return this.elements.shift();\n  }\n}\n", "import { Websocket } from \"./websocket\";\n\n/**\n * Events that can be fired by the websocket.\n */\nexport enum WebsocketEvent {\n  /** Fired when the connection is opened. */\n  open = \"open\",\n\n  /** Fired when the connection is closed. */\n  close = \"close\",\n\n  /** Fired when the connection has been closed because of an error, such as when some data couldn't be sent. */\n  error = \"error\",\n\n  /** Fired when a message is received. */\n  message = \"message\",\n\n  /** Fired when the websocket tries to reconnect after a connection loss. */\n  retry = \"retry\",\n\n  /** Fired when the websocket successfully reconnects after a connection loss. */\n  reconnect = \"reconnect\",\n}\n\n/***\n * Details/properties of a retry-event.\n */\nexport type RetryEventDetail = {\n  /** Number of retries that have been made since the connection was lost. */\n  readonly retries: number;\n\n  /** Time (ms) waited since the last connection-retry. */\n  readonly backoff: number;\n\n  /** Timestamp of when the connection was lost or undefined if the connection has never been established. */\n  readonly lastConnection: Date | undefined;\n};\n\n/**\n * Properties of a reconnect-event.\n */\nexport type ReconnectEventDetail = Omit<RetryEventDetail, \"backoff\">;\n\n/**\n * Maps websocket events to their corresponding event.\n */\nexport type WebsocketEventMap = {\n  [WebsocketEvent.open]: Event;\n  [WebsocketEvent.close]: CloseEvent;\n  [WebsocketEvent.error]: Event;\n  [WebsocketEvent.message]: MessageEvent;\n  [WebsocketEvent.retry]: CustomEvent<RetryEventDetail>;\n  [WebsocketEvent.reconnect]: CustomEvent<ReconnectEventDetail>;\n};\n\n/**\n * Listener for websocket events.\n * */\nexport type WebsocketEventListener<K extends WebsocketEvent> = (\n  instance: Websocket,\n  ev: WebsocketEventMap[K],\n) => unknown;\n\nexport type WebsocketEventListenerParams<K extends WebsocketEvent> = Parameters<\n  WebsocketEventListener<K>\n>;\n\n/**\n * Options for websocket events.\n */\nexport type WebsocketEventListenerOptions = EventListenerOptions &\n  AddEventListenerOptions;\n\n/**\n * Listener for websocket events with options.\n */\nexport type WebsocketEventListenerWithOptions<K extends WebsocketEvent> = {\n  readonly listener: WebsocketEventListener<K>;\n  readonly options?: WebsocketEventListenerOptions;\n};\n\n/**\n * Maps websocket events to their corresponding event-listeners.\n */\nexport type WebsocketEventListeners = {\n  [K in WebsocketEvent]: WebsocketEventListenerWithOptions<K>[];\n};\n", "import { Backoff } from \"./backoff/backoff\";\nimport { WebsocketBuffer } from \"./websocket_buffer\";\nimport {\n  ReconnectEventDetail,\n  RetryEventDetail,\n  WebsocketEvent,\n  WebsocketEventListener,\n  WebsocketEventListenerOptions,\n  WebsocketEventListeners,\n  WebsocketEventListenerWithOptions,\n  WebsocketEventMap,\n} from \"./websocket_event\";\nimport { WebsocketOptions } from \"./websocket_options\";\n\n/**\n * A websocket wrapper that can be configured to reconnect automatically and buffer messages when the websocket is not connected.\n */\nexport class Websocket {\n  private readonly _url: string; // the url to connect to\n  private readonly _protocols?: string | string[]; // the protocols to use\n\n  private _closedByUser: boolean = false; // whether the websocket was closed by the user\n  private _lastConnection?: Date; // timestamp of the last connection\n  private _underlyingWebsocket: WebSocket; // the underlying websocket, e.g. native browser websocket\n  private retryTimeout?: ReturnType<typeof globalThis.setTimeout>; // timeout for the next retry, if any\n\n  private _options: WebsocketOptions &\n    Required<Pick<WebsocketOptions, \"listeners\" | \"retry\">>; // options/config for the websocket\n\n  /**\n   * Creates a new websocket.\n   *\n   * @param url to connect to.\n   * @param protocols optional protocols to use.\n   * @param options optional options to use.\n   */\n  constructor(\n    url: string,\n    protocols?: string | string[],\n    options?: WebsocketOptions,\n  ) {\n    this._url = url;\n    this._protocols = protocols;\n\n    // make a copy of the options to prevent the user from changing them\n    this._options = {\n      buffer: options?.buffer,\n      retry: {\n        maxRetries: options?.retry?.maxRetries,\n        instantReconnect: options?.retry?.instantReconnect,\n        backoff: options?.retry?.backoff,\n      },\n      listeners: {\n        open: [...(options?.listeners?.open ?? [])],\n        close: [...(options?.listeners?.close ?? [])],\n        error: [...(options?.listeners?.error ?? [])],\n        message: [...(options?.listeners?.message ?? [])],\n        retry: [...(options?.listeners?.retry ?? [])],\n        reconnect: [...(options?.listeners?.reconnect ?? [])],\n      },\n    };\n\n    this._underlyingWebsocket = this.tryConnect();\n  }\n\n  /**\n   * Getter for the url.\n   *\n   * @return the url.\n   */\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Getter for the protocols.\n   *\n   * @return the protocols, or undefined if none were provided.\n   */\n  get protocols(): string | string[] | undefined {\n    return this._protocols;\n  }\n\n  /**\n   * Getter for the buffer.\n   *\n   * @return the buffer, or undefined if none was provided.\n   */\n  get buffer(): WebsocketBuffer | undefined {\n    return this._options.buffer;\n  }\n\n  /**\n   * Getter for the maxRetries.\n   *\n   * @return the maxRetries, or undefined if none was provided (no limit).\n   */\n  get maxRetries(): number | undefined {\n    return this._options.retry.maxRetries;\n  }\n\n  /**\n   * Getter for the instantReconnect.\n   *\n   * @return the instantReconnect, or undefined if none was provided.\n   */\n  get instantReconnect(): boolean | undefined {\n    return this._options.retry.instantReconnect;\n  }\n\n  /**\n   * Getter for the backoff.\n   *\n   * @return the backoff, or undefined if none was provided.\n   */\n  get backoff(): Backoff | undefined {\n    return this._options.retry.backoff;\n  }\n\n  /**\n   * Whether the websocket was closed by the user. A websocket is closed by the user by calling close().\n   *\n   * @return true if the websocket was closed by the user, false otherwise.\n   */\n  get closedByUser(): boolean {\n    return this._closedByUser;\n  }\n\n  /**\n   * Getter for the last 'open' event, e.g. the last time the websocket was connected.\n   *\n   * @return the last 'open' event, or undefined if the websocket was never connected.\n   */\n  get lastConnection(): Date | undefined {\n    return this._lastConnection;\n  }\n\n  /**\n   * Getter for the underlying websocket. This can be used to access the browser's native websocket directly.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @return the underlying websocket.\n   */\n  get underlyingWebsocket(): WebSocket {\n    return this._underlyingWebsocket;\n  }\n\n  /**\n   * Getter for the readyState of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n   * @return the readyState of the underlying websocket.\n   */\n  get readyState(): number {\n    return this._underlyingWebsocket.readyState;\n  }\n\n  /**\n   * Getter for the bufferedAmount of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount\n   * @return the bufferedAmount of the underlying websocket.\n   */\n  get bufferedAmount(): number {\n    return this._underlyingWebsocket.bufferedAmount;\n  }\n\n  /**\n   * Getter for the extensions of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions\n   * @return the extensions of the underlying websocket.\n   */\n  get extensions(): string {\n    return this._underlyingWebsocket.extensions;\n  }\n\n  /**\n   * Getter for the binaryType of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType\n   * @return the binaryType of the underlying websocket.\n   */\n  get binaryType(): BinaryType {\n    return this._underlyingWebsocket.binaryType;\n  }\n\n  /**\n   * Setter for the binaryType of the underlying websocket.\n   *\n   * @param value to set, 'blob' or 'arraybuffer'.\n   */\n  set binaryType(value: BinaryType) {\n    this._underlyingWebsocket.binaryType = value;\n  }\n\n  /**\n   * Sends data over the websocket.\n   *\n   * If the websocket is not connected and a buffer was provided on creation, the data will be added to the buffer.\n   * If no buffer was provided or the websocket was closed by the user, the data will be dropped.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   * @param data to send.\n   */\n  public send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n    if (this.closedByUser) return; // no-op if closed by user\n\n    if (\n      this._underlyingWebsocket.readyState === this._underlyingWebsocket.OPEN\n    ) {\n      this._underlyingWebsocket.send(data); // websocket is connected, send data\n    } else if (this.buffer !== undefined) {\n      this.buffer.add(data); // websocket is not connected, add data to buffer\n    }\n  }\n\n  /**\n   * Close the websocket. No connection-retry will be attempted after this.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n   * @param code optional close code.\n   * @param reason optional close reason.\n   */\n  public close(code?: number, reason?: string): void {\n    this.cancelScheduledConnectionRetry(); // cancel any scheduled retries\n    this._closedByUser = true; // mark websocket as closed by user\n    this._underlyingWebsocket.close(code, reason); // close underlying websocket with provided code and reason\n  }\n\n  /**\n   * Adds an event listener for the given event-type.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   * @param type of the event to add the listener for.\n   * @param listener to add.\n   * @param options to use when adding the listener.\n   */\n  public addEventListener<K extends WebsocketEvent>(\n    type: K,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): void {\n    this._options.listeners[type].push({ listener, options }); // add listener to list of listeners\n  }\n\n  /**\n   * Removes one or more event listener for the given event-type that match the given listener and options.\n   *\n   * @param type of the event to remove the listener for.\n   * @param listener to remove.\n   * @param options that were used when the listener was added.\n   */\n  public removeEventListener<K extends WebsocketEvent>(\n    type: K,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): void {\n    const isListenerNotToBeRemoved = (\n      l: WebsocketEventListenerWithOptions<K>,\n    ) => l.listener !== listener || l.options !== options;\n\n    (this._options.listeners[type] as WebsocketEventListenerWithOptions<K>[]) =\n      this._options.listeners[type].filter(isListenerNotToBeRemoved); // only keep listeners that are not to be removed\n  }\n\n  /**\n   * Creates a new browser-native websocket and connects it to the given URL with the given protocols\n   * and adds all event listeners to the browser-native websocket.\n   *\n   * @return the created browser-native websocket which is also stored in the '_underlyingWebsocket' property.\n   */\n  private tryConnect(): WebSocket {\n    this._underlyingWebsocket = new WebSocket(this.url, this.protocols); // create new browser-native websocket and add all event listeners\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.open,\n      this.handleOpenEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.close,\n      this.handleCloseEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.error,\n      this.handleErrorEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.message,\n      this.handleMessageEvent,\n    );\n\n    return this._underlyingWebsocket;\n  }\n\n  /**\n   * Removes all event listeners from the browser-native websocket and closes it.\n   */\n  private clearWebsocket() {\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.open,\n      this.handleOpenEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.close,\n      this.handleCloseEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.error,\n      this.handleErrorEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.message,\n      this.handleMessageEvent,\n    );\n    this._underlyingWebsocket.close();\n  }\n\n  /**\n   * Handles the 'open' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleOpenEvent = (event: Event) =>\n    this.handleEvent(WebsocketEvent.open, event);\n\n  /**\n   * Handles the 'error' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleErrorEvent = (event: Event) =>\n    this.handleEvent(WebsocketEvent.error, event);\n\n  /**\n   * Handles the 'close' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleCloseEvent = (event: CloseEvent) =>\n    this.handleEvent(WebsocketEvent.close, event);\n\n  /**\n   * Handles the 'message' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleMessageEvent = (event: MessageEvent) =>\n    this.handleEvent(WebsocketEvent.message, event);\n\n  /**\n   * Dispatch an event to all listeners of the given event-type.\n   *\n   * @param type of the event to dispatch.\n   * @param event to dispatch.\n   */\n  private dispatchEvent<K extends WebsocketEvent>(\n    type: K,\n    event: WebsocketEventMap[K],\n  ) {\n    const eventListeners: WebsocketEventListeners[K] =\n      this._options.listeners[type];\n    const newEventListeners: WebsocketEventListeners[K] = [];\n\n    eventListeners.forEach(({ listener, options }) => {\n      listener(this, event); // invoke listener with event\n\n      if (\n        options === undefined ||\n        options.once === undefined ||\n        !options.once\n      ) {\n        newEventListeners.push({ listener, options }); // only keep listener if it isn't a once-listener\n      }\n    });\n\n    this._options.listeners[type] = newEventListeners; // replace old listeners with new listeners that don't include once-listeners\n  }\n\n  /**\n   * Handles the given event by dispatching it to all listeners of the given event-type.\n   *\n   * @param type of the event to handle.\n   * @param event to handle.\n   */\n  private handleEvent<K extends WebsocketEvent>(\n    type: K,\n    event: WebsocketEventMap[K],\n  ) {\n    switch (type) {\n      case WebsocketEvent.close:\n        this.dispatchEvent(type, event);\n        this.scheduleConnectionRetryIfNeeded(); // schedule a new connection retry if the websocket was closed by the server\n        break;\n\n      case WebsocketEvent.open:\n        if (this.backoff !== undefined && this._lastConnection !== undefined) {\n          // websocket was reconnected, dispatch reconnect event and reset backoff\n          const detail: ReconnectEventDetail = {\n            retries: this.backoff.retries,\n            lastConnection: new Date(this._lastConnection),\n          };\n          const event: CustomEvent<ReconnectEventDetail> =\n            new CustomEvent<ReconnectEventDetail>(WebsocketEvent.reconnect, {\n              detail,\n            });\n          this.dispatchEvent(WebsocketEvent.reconnect, event);\n          this.backoff.reset();\n        }\n        this._lastConnection = new Date();\n        this.dispatchEvent(type, event); // dispatch open event and send buffered data\n        this.sendBufferedData();\n        break;\n\n      case WebsocketEvent.retry:\n        this.dispatchEvent(type, event); // dispatch retry event and try to connect\n        this.clearWebsocket(); // clear the old websocket\n        this.tryConnect();\n        break;\n\n      default:\n        this.dispatchEvent(type, event); // dispatch event to all listeners of the given event-type\n        break;\n    }\n  }\n\n  /**\n   * Sends buffered data if there is a buffer defined.\n   */\n  private sendBufferedData() {\n    if (this.buffer === undefined) {\n      return; // no buffer defined, nothing to send\n    }\n\n    for (\n      let ele = this.buffer.read();\n      ele !== undefined;\n      ele = this.buffer.read()\n    ) {\n      this.send(ele); // send buffered data\n    }\n  }\n\n  /**\n   * Schedules a connection-retry if there is a backoff defined and the websocket was not closed by the user.\n   */\n  private scheduleConnectionRetryIfNeeded() {\n    if (this.closedByUser) {\n      return; // user closed the websocket, no retry\n    }\n    if (this.backoff === undefined) {\n      return; // no backoff defined, no retry\n    }\n\n    // handler dispatches the retry event to all listeners of the retry event-type\n    const handleRetryEvent = (detail: RetryEventDetail) => {\n      const event: CustomEvent<RetryEventDetail> = new CustomEvent(\n        WebsocketEvent.retry,\n        { detail },\n      );\n      this.handleEvent(WebsocketEvent.retry, event);\n    };\n\n    // create retry event detail, depending on the 'instantReconnect' option\n    const retryEventDetail: RetryEventDetail = {\n      backoff:\n        this._options.retry.instantReconnect === true ? 0 : this.backoff.next(),\n      retries:\n        this._options.retry.instantReconnect === true\n          ? 0\n          : this.backoff.retries,\n      lastConnection: this._lastConnection,\n    };\n\n    // schedule a new connection-retry if the maximum number of retries is not reached yet\n    if (\n      this._options.retry.maxRetries === undefined ||\n      retryEventDetail.retries <= this._options.retry.maxRetries\n    ) {\n      this.retryTimeout = globalThis.setTimeout(\n        () => handleRetryEvent(retryEventDetail),\n        retryEventDetail.backoff,\n      );\n    }\n  }\n\n  /**\n   * Cancels the scheduled connection-retry, if there is one.\n   */\n  private cancelScheduledConnectionRetry() {\n    globalThis.clearTimeout(this.retryTimeout);\n  }\n}\n", "import { Backoff } from \"./backoff/backoff\";\nimport {\n  WebsocketEvent,\n  WebsocketEventListener,\n  WebsocketEventListenerOptions,\n} from \"./websocket_event\";\nimport { Websocket } from \"./websocket\";\nimport { WebsocketBuffer } from \"./websocket_buffer\";\nimport { WebsocketOptions } from \"./websocket_options\";\n\n/**\n * Builder for websockets.\n */\nexport class WebsocketBuilder {\n  private readonly _url: string;\n\n  private _protocols?: string | string[];\n  private _options?: WebsocketOptions;\n\n  /**\n   * Creates a new WebsocketBuilder.\n   *\n   * @param url the url to connect to\n   */\n  constructor(url: string) {\n    this._url = url;\n  }\n\n  /**\n   * Getter for the url.\n   *\n   * @returns the url\n   */\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.\n   *\n   * @param protocols the protocols to add\n   */\n  public withProtocols(\n    protocols: string | string[] | undefined,\n  ): WebsocketBuilder {\n    this._protocols = protocols;\n    return this;\n  }\n\n  /**\n   * Getter for the protocols.\n   *\n   * @returns the protocols, undefined if no protocols have been set\n   */\n  get protocols(): string | string[] | undefined {\n    return this._protocols;\n  }\n\n  /**\n   * Sets the maximum number of retries before giving up. No limit if undefined.\n   *\n   * @param maxRetries the maximum number of retries before giving up\n   */\n  public withMaxRetries(maxRetries: number | undefined): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, maxRetries },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for the maximum number of retries before giving up.\n   *\n   * @returns the maximum number of retries before giving up, undefined if no maximum has been set\n   */\n  get maxRetries(): number | undefined {\n    return this._options?.retry?.maxRetries;\n  }\n\n  /**\n   * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.\n   *\n   * @param instantReconnect wether to reconnect immediately after a connection has been lost\n   */\n  public withInstantReconnect(\n    instantReconnect: boolean | undefined,\n  ): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, instantReconnect },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.\n   *\n   * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set\n   */\n  get instantReconnect(): boolean | undefined {\n    return this._options?.retry?.instantReconnect;\n  }\n\n  /**\n   * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.\n   *\n   * @param backoff the backoff to add\n   */\n  public withBackoff(backoff: Backoff | undefined): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, backoff },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for the backoff.\n   *\n   * @returns the backoff, undefined if no backoff has been set\n   */\n  get backoff(): Backoff | undefined {\n    return this._options?.retry?.backoff;\n  }\n\n  /**\n   * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.\n   *\n   * @param buffer the buffer to add\n   */\n  public withBuffer(buffer: WebsocketBuffer | undefined): WebsocketBuilder {\n    this._options = { ...this._options, buffer };\n    return this;\n  }\n\n  /**\n   * Getter for the buffer.\n   *\n   * @returns the buffer, undefined if no buffer has been set\n   */\n  get buffer(): WebsocketBuffer | undefined {\n    return this._options?.buffer;\n  }\n\n  /**\n   * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onOpen(\n    listener: WebsocketEventListener<WebsocketEvent.open>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.open, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onClose(\n    listener: WebsocketEventListener<WebsocketEvent.close>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.close, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onError(\n    listener: WebsocketEventListener<WebsocketEvent.error>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.error, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onMessage(\n    listener: WebsocketEventListener<WebsocketEvent.message>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.message, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onRetry(\n    listener: WebsocketEventListener<WebsocketEvent.retry>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.retry, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onReconnect(\n    listener: WebsocketEventListener<WebsocketEvent.reconnect>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.reconnect, listener, options);\n    return this;\n  }\n\n  /**\n   * Builds the websocket.\n   *\n   * @return a new websocket, with the set options\n   */\n  public build(): Websocket {\n    return new Websocket(this._url, this._protocols, this._options); // instantiate the websocket with the set options\n  }\n\n  /**\n   * Adds an event listener to the options.\n   *\n   * @param event the event to add the listener to\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  private addListener<K extends WebsocketEvent>(\n    event: WebsocketEvent,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      listeners: {\n        open: this._options?.listeners?.open ?? [],\n        close: this._options?.listeners?.close ?? [],\n        error: this._options?.listeners?.error ?? [],\n        message: this._options?.listeners?.message ?? [],\n        retry: this._options?.listeners?.retry ?? [],\n        reconnect: this._options?.listeners?.reconnect ?? [],\n        [event]: [\n          ...(this._options?.listeners?.[event] ?? []),\n          { listener, options },\n        ],\n      },\n    };\n    return this;\n  }\n}\n", "import { getFilterLimit, matchFilters, verifyEvent as _verifyEvent } from \"nostr-tools\";\nimport { ArrayQueue, ExponentialBackoff, WebsocketBuilder, WebsocketEvent } from \"websocket-ts\";\nimport { Machina } from \"./utils/Machina.js\";\nimport { NSchema as n } from \"./NSchema.js\";\nimport { NSet } from \"./NSet.js\";\nclass NRelay1 {\n  socket;\n  subs = /* @__PURE__ */ new Map();\n  closedByUser = false;\n  idleTimer;\n  controller = new AbortController();\n  url;\n  opts;\n  ee = new EventTarget();\n  get subscriptions() {\n    return [...this.subs.values()];\n  }\n  log(log) {\n    this.opts.log?.({ ...log, url: this.url });\n  }\n  constructor(url, opts = {}) {\n    this.url = url;\n    this.opts = opts;\n    this.socket = this.createSocket();\n    this.maybeStartIdleTimer();\n  }\n  /** Create (and open) a WebSocket connection with automatic reconnect. */\n  createSocket() {\n    const { backoff = new ExponentialBackoff(1e3) } = this.opts;\n    return new WebsocketBuilder(this.url).withBuffer(new ArrayQueue()).withBackoff(backoff === false ? void 0 : backoff).onOpen((socket) => {\n      this.log({\n        level: \"debug\",\n        ns: \"relay.ws.state\",\n        state: \"open\",\n        readyState: socket.readyState\n      });\n      for (const req of this.subs.values()) {\n        this.send(req);\n      }\n    }).onClose((socket) => {\n      this.log({\n        level: \"debug\",\n        ns: \"relay.ws.state\",\n        state: \"close\",\n        readyState: socket.readyState\n      });\n      if (!this.subs.size) {\n        this.socket.close();\n      }\n    }).onReconnect((socket) => {\n      this.log({\n        level: \"debug\",\n        ns: \"relay.ws.state\",\n        state: \"reconnect\",\n        readyState: socket.readyState\n      });\n    }).onRetry((socket, e) => {\n      this.log({\n        level: \"warn\",\n        ns: \"relay.ws.retry\",\n        readyState: socket.readyState,\n        backoff: e.detail.backoff\n      });\n    }).onError((socket) => {\n      this.log({\n        level: \"error\",\n        ns: \"relay.ws.error\",\n        readyState: socket.readyState\n      });\n    }).onMessage((_socket, e) => {\n      if (typeof e.data !== \"string\") {\n        this.close();\n        return;\n      }\n      const result = n.json().pipe(n.relayMsg()).safeParse(e.data);\n      if (result.success) {\n        this.log({\n          level: \"trace\",\n          ns: \"relay.ws.message\",\n          data: result.data\n        });\n        this.receive(result.data);\n      } else {\n        this.log({\n          level: \"warn\",\n          ns: \"relay.ws.message\",\n          error: result.error\n        });\n      }\n    }).build();\n  }\n  /** Handle a NIP-01 relay message. */\n  receive(msg) {\n    const { auth, verifyEvent = _verifyEvent } = this.opts;\n    switch (msg[0]) {\n      case \"EVENT\":\n        if (!verifyEvent(msg[2])) break;\n        this.ee.dispatchEvent(\n          new CustomEvent(`sub:${msg[1]}`, { detail: msg })\n        );\n        break;\n      case \"EOSE\":\n        this.ee.dispatchEvent(\n          new CustomEvent(`sub:${msg[1]}`, { detail: msg })\n        );\n        break;\n      case \"CLOSED\":\n        this.subs.delete(msg[1]);\n        this.maybeStartIdleTimer();\n        this.ee.dispatchEvent(\n          new CustomEvent(`sub:${msg[1]}`, { detail: msg })\n        );\n        this.ee.dispatchEvent(\n          new CustomEvent(`count:${msg[1]}`, { detail: msg })\n        );\n        break;\n      case \"OK\":\n        this.ee.dispatchEvent(new CustomEvent(`ok:${msg[1]}`, { detail: msg }));\n        break;\n      case \"NOTICE\":\n        this.ee.dispatchEvent(new CustomEvent(\"notice\", { detail: msg }));\n        break;\n      case \"COUNT\":\n        this.ee.dispatchEvent(\n          new CustomEvent(`count:${msg[1]}`, { detail: msg })\n        );\n        break;\n      case \"AUTH\":\n        auth?.(msg[1]).then((event) => this.send([\"AUTH\", event])).catch(\n          () => {\n          }\n        );\n    }\n  }\n  /** Send a NIP-01 client message to the relay. */\n  send(msg) {\n    this.log({ level: \"trace\", ns: \"relay.ws.send\", data: msg });\n    this.wake();\n    switch (msg[0]) {\n      case \"REQ\":\n        this.subs.set(msg[1], msg);\n        break;\n      case \"CLOSE\":\n        this.subs.delete(msg[1]);\n        this.maybeStartIdleTimer();\n        break;\n      case \"EVENT\":\n      case \"COUNT\":\n        return this.socket.send(JSON.stringify(msg));\n    }\n    if (this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(msg));\n    }\n  }\n  async *req(filters, opts = {}) {\n    const { signal } = opts;\n    const subscriptionId = crypto.randomUUID();\n    const msgs = this.on(`sub:${subscriptionId}`, signal);\n    const req = [\"REQ\", subscriptionId, ...filters];\n    this.send(req);\n    try {\n      for await (const msg of msgs) {\n        if (msg[0] === \"EOSE\") yield msg;\n        if (msg[0] === \"CLOSED\") break;\n        if (msg[0] === \"EVENT\") {\n          if (matchFilters(filters, msg[2])) {\n            yield msg;\n          } else {\n            continue;\n          }\n        }\n      }\n    } finally {\n      this.send([\"CLOSE\", subscriptionId]);\n    }\n  }\n  async query(filters, opts) {\n    const events = new NSet();\n    const limit = filters.reduce(\n      (result, filter) => result + getFilterLimit(filter),\n      0\n    );\n    if (limit === 0) return [];\n    for await (const msg of this.req(filters, opts)) {\n      if (msg[0] === \"EOSE\") break;\n      if (msg[0] === \"EVENT\") events.add(msg[2]);\n      if (msg[0] === \"CLOSED\") throw new Error(\"Subscription closed\");\n      if (events.size >= limit) {\n        break;\n      }\n    }\n    return [...events];\n  }\n  async event(event, opts) {\n    const result = this.once(`ok:${event.id}`, opts?.signal);\n    try {\n      this.send([\"EVENT\", event]);\n    } catch (e) {\n      result.catch(() => {\n      });\n      throw e;\n    }\n    const [, , ok, reason] = await result;\n    if (!ok) {\n      throw new Error(reason);\n    }\n  }\n  async count(filters, opts) {\n    const subscriptionId = crypto.randomUUID();\n    const result = this.once(`count:${subscriptionId}`, opts?.signal);\n    try {\n      this.send([\"COUNT\", subscriptionId, ...filters]);\n    } catch (e) {\n      result.catch(() => {\n      });\n      throw e;\n    }\n    const msg = await result;\n    switch (msg[0]) {\n      case \"CLOSED\":\n        throw new Error(\"Subscription closed\");\n      case \"COUNT\": {\n        const [, , count] = msg;\n        return count;\n      }\n    }\n    throw new Error(\"Count ended -- this should never happen\");\n  }\n  /** Get a stream of EE events. */\n  async *on(key, signal) {\n    const _signal = signal ? AbortSignal.any([this.controller.signal, signal]) : this.controller.signal;\n    if (_signal.aborted) throw this.abortError();\n    const machina = new Machina(_signal);\n    const onMsg = (e) => machina.push(e.detail);\n    this.ee.addEventListener(key, onMsg);\n    try {\n      for await (const msg of machina) {\n        yield msg;\n      }\n    } finally {\n      this.ee.removeEventListener(key, onMsg);\n    }\n  }\n  /** Wait for a single EE event. */\n  async once(key, signal) {\n    for await (const msg of this.on(key, signal)) {\n      return msg;\n    }\n    throw new Error(\"Unreachable\");\n  }\n  abortError() {\n    return new DOMException(\"The signal has been aborted\", \"AbortError\");\n  }\n  /** Start the idle time if applicable. */\n  maybeStartIdleTimer() {\n    const { idleTimeout = 3e4 } = this.opts;\n    if (idleTimeout === false) return;\n    if (this.idleTimer) return;\n    if (this.subs.size) return;\n    if (this.closedByUser) return;\n    this.log({\n      level: \"debug\",\n      ns: \"relay.idletimer\",\n      state: \"running\",\n      timeout: idleTimeout\n    });\n    this.idleTimer = setTimeout(() => {\n      this.log({\n        level: \"debug\",\n        ns: \"relay.idletimer\",\n        state: \"aborted\",\n        timeout: idleTimeout\n      });\n      this.socket.close();\n    }, idleTimeout);\n  }\n  /** Stop the idle timer. */\n  stopIdleTimer() {\n    this.log({ level: \"debug\", ns: \"relay.idletimer\", state: \"stopped\" });\n    clearTimeout(this.idleTimer);\n    this.idleTimer = void 0;\n  }\n  /** Make a new WebSocket, but only if it was closed by an idle timeout. */\n  wake() {\n    this.stopIdleTimer();\n    if (!this.closedByUser && this.socket.closedByUser) {\n      this.log({ level: \"debug\", ns: \"relay.wake\", state: \"awoken\" });\n      this.socket = this.createSocket();\n    } else if (this.closedByUser || this.socket.closedByUser) {\n      this.log({ level: \"debug\", ns: \"relay.wake\", state: \"closed\" });\n    } else {\n      this.log({ level: \"debug\", ns: \"relay.wake\", state: \"awake\" });\n    }\n  }\n  /**\n   * Close the relay connection and prevent it from reconnecting.\n   * After this you should dispose of the `NRelay1` instance and create a new one to connect again.\n   */\n  async close() {\n    this.closedByUser = true;\n    this.socket.close();\n    this.stopIdleTimer();\n    this.controller.abort();\n    if (this.socket.readyState !== WebSocket.CLOSED) {\n      await new Promise((resolve) => {\n        this.socket.addEventListener(WebsocketEvent.close, resolve, {\n          once: true\n        });\n      });\n    }\n  }\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n}\nexport {\n  NRelay1\n};\n", "import { finalizeEvent, getPublicKey, nip04, nip44 } from \"nostr-tools\";\nclass NSecSigner {\n  #secretKey;\n  pubkey;\n  constructor(secretKey) {\n    this.#secretKey = secretKey;\n  }\n  async getPublicKey() {\n    return this.pubkey ??= getPublicKey(this.#secretKey);\n  }\n  async signEvent(event) {\n    return finalizeEvent(event, this.#secretKey);\n  }\n  nip04 = {\n    encrypt: async (pubkey, plaintext) => {\n      return nip04.encrypt(this.#secretKey, pubkey, plaintext);\n    },\n    decrypt: async (pubkey, ciphertext) => {\n      return nip04.decrypt(this.#secretKey, pubkey, ciphertext);\n    }\n  };\n  #getConversationKey(pubkey) {\n    return nip44.v2.utils.getConversationKey(this.#secretKey, pubkey);\n  }\n  nip44 = {\n    encrypt: async (pubkey, plaintext) => {\n      const conversationKey = this.#getConversationKey(pubkey);\n      return nip44.v2.encrypt(plaintext, conversationKey);\n    },\n    decrypt: async (pubkey, ciphertext) => {\n      const conversationKey = this.#getConversationKey(pubkey);\n      return nip44.v2.decrypt(ciphertext, conversationKey);\n    }\n  };\n}\nexport {\n  NSecSigner\n};\n", "class RelayError extends Error {\n  constructor(prefix, message) {\n    super(`${prefix}: ${message}`);\n  }\n  /** Construct a RelayError from the reason message. */\n  static fromReason(reason) {\n    const [prefix, ...rest] = reason.split(\": \");\n    return new RelayError(prefix, rest.join(\": \"));\n  }\n  /** Throw a new RelayError if the OK message is false. */\n  static assert(msg) {\n    const [, , ok, reason] = msg;\n    if (!ok) {\n      throw RelayError.fromReason(reason);\n    }\n  }\n}\nexport {\n  RelayError\n};\n"],
  "mappings": "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",
  "names": ["_a", "_b", "v", "bf", "_a", "_b", "_a", "_b", "_a", "_resolve", "_a", "WebsocketEvent", "_a", "_b", "event", "_a", "_b", "_a", "_b", "verifyEvent"]
}
