import {
  BunkerURI,
  NBrowserSigner,
  NConnectSigner,
  NSecSigner
} from "./chunk-V3KPUVO3.js";
import {
  generateSecretKey,
  getPublicKey,
  nip19_exports
} from "./chunk-RHRR5RQ3.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/@nostrify/react/dist/login/NLogin.js
var NLogin = class _NLogin {
  constructor(type, pubkey, data) {
    __publicField(this, "id");
    __publicField(this, "type");
    __publicField(this, "pubkey");
    __publicField(this, "createdAt");
    __publicField(this, "data");
    this.id = `${type}:${pubkey}`;
    this.type = type;
    this.pubkey = pubkey;
    this.createdAt = (/* @__PURE__ */ new Date()).toISOString();
    this.data = data;
  }
  /** Create a login object from an nsec. */
  static fromNsec(nsec) {
    const decoded = nip19_exports.decode(nsec);
    if (decoded.type !== "nsec") {
      throw new Error("Invalid nsec");
    }
    const sk = decoded.data;
    const pubkey = getPublicKey(sk);
    return new _NLogin("nsec", pubkey, {
      nsec: nip19_exports.nsecEncode(sk)
    });
  }
  /** Create a login object from a bunker URI. */
  static async fromBunker(uri, pool) {
    const { pubkey: bunkerPubkey, secret, relays } = new BunkerURI(uri);
    if (!relays.length) {
      throw new Error("No relay provided");
    }
    const sk = generateSecretKey();
    const nsec = nip19_exports.nsecEncode(sk);
    const clientSigner = new NSecSigner(sk);
    const signer = new NConnectSigner({
      relay: pool.group(relays),
      pubkey: bunkerPubkey,
      signer: clientSigner,
      timeout: 6e4
    });
    await signer.connect(secret);
    const pubkey = await signer.getPublicKey();
    return new _NLogin("bunker", pubkey, {
      bunkerPubkey,
      clientNsec: nsec,
      relays
    });
  }
  /** Create a login object from a browser extension. */
  static async fromExtension() {
    const windowSigner = globalThis.nostr;
    if (!windowSigner) {
      throw new Error("Nostr extension is not available");
    }
    const pubkey = await windowSigner.getPublicKey();
    return new _NLogin("extension", pubkey, null);
  }
  /** Convert to a JSON-serializable object. */
  toJSON() {
    return {
      id: this.id,
      type: this.type,
      pubkey: this.pubkey,
      createdAt: this.createdAt,
      data: this.data
    };
  }
};

// node_modules/@nostrify/react/dist/login/NostrLoginProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@nostrify/react/dist/login/NostrLoginContext.js
var import_react = __toESM(require_react(), 1);
var NostrLoginContext = (0, import_react.createContext)(void 0);

// node_modules/@nostrify/react/dist/login/useNostrLoginReducer.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@nostrify/react/dist/login/nostrLoginReducer.js
function nostrLoginReducer(state, action) {
  switch (action.type) {
    case "login.add": {
      const filtered = state.filter((login) => login.id !== action.login.id);
      return action.set ? [action.login, ...filtered] : [...filtered, action.login];
    }
    case "login.remove": {
      return state.filter((login) => login.id !== action.id);
    }
    case "login.set": {
      const login = state.find((login2) => login2.id === action.id);
      if (!login) {
        return state;
      }
      const filtered = state.filter((login2) => login2.id !== action.id);
      return [login, ...filtered];
    }
    case "login.clear": {
      return [];
    }
    default: {
      return state;
    }
  }
}

// node_modules/@nostrify/react/dist/login/useNostrLoginReducer.js
function useNostrLoginReducer(storageKey) {
  const [state, dispatch] = (0, import_react2.useReducer)(nostrLoginReducer, [], () => {
    const stored = localStorage.getItem(storageKey);
    return stored ? JSON.parse(stored) : [];
  });
  (0, import_react2.useEffect)(() => {
    localStorage.setItem(storageKey, JSON.stringify(state));
  }, [state]);
  return [state, dispatch];
}

// node_modules/@nostrify/react/dist/login/NostrLoginProvider.js
var NostrLoginProvider = ({ children, storageKey }) => {
  const [logins, dispatch] = useNostrLoginReducer(storageKey);
  const value = {
    logins,
    addLogin: (login) => dispatch({ type: "login.add", login }),
    removeLogin: (id) => dispatch({ type: "login.remove", id }),
    setLogin: (id) => dispatch({ type: "login.set", id }),
    clearLogins: () => dispatch({ type: "login.clear" })
  };
  return (0, import_jsx_runtime.jsx)(NostrLoginContext.Provider, { value, children });
};

// node_modules/@nostrify/react/dist/login/NUser.js
var NUser = class _NUser {
  constructor(method, pubkey, signer) {
    this.method = method;
    this.pubkey = pubkey;
    this.signer = signer;
  }
  static fromNsecLogin(login) {
    const sk = nip19_exports.decode(login.data.nsec);
    return new _NUser(
      login.type,
      login.pubkey,
      new NSecSigner(sk.data)
    );
  }
  static fromBunkerLogin(login, pool) {
    const clientSk = nip19_exports.decode(login.data.clientNsec);
    const clientSigner = new NSecSigner(clientSk.data);
    return new _NUser(
      login.type,
      login.pubkey,
      new NConnectSigner({
        relay: pool.group(login.data.relays),
        pubkey: login.pubkey,
        signer: clientSigner,
        timeout: 6e4
      })
    );
  }
  static fromExtensionLogin(login) {
    return new _NUser(
      login.type,
      login.pubkey,
      new NBrowserSigner()
    );
  }
};

// node_modules/@nostrify/react/dist/login/useNostrLogin.js
var import_react3 = __toESM(require_react(), 1);
function useNostrLogin() {
  const context = (0, import_react3.useContext)(NostrLoginContext);
  if (!context) {
    throw new Error("useNostrLogin must be used within a NostrLoginProvider");
  }
  return context;
}

export {
  NLogin,
  NostrLoginProvider,
  NUser,
  useNostrLogin
};
//# sourceMappingURL=chunk-ULXXJGQE.js.map
