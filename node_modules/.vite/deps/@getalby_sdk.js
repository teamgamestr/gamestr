import {
  Relay,
  finalizeEvent,
  generateSecretKey,
  getEventHash,
  getPublicKey,
  nip04_exports,
  nip19_exports,
  nip44_exports
} from "./chunk-RHRR5RQ3.js";
import "./chunk-WOOG5QLI.js";

// node_modules/@getalby/lightning-tools/dist/index.modern.js
var e;
var t;
var r = (e = function(e2, t2) {
  function r2(e3) {
    if (!Number.isSafeInteger(e3)) throw new Error(`Wrong integer: ${e3}`);
  }
  function n2(...e3) {
    const t3 = (e4, t4) => (r3) => e4(t4(r3));
    return { encode: Array.from(e3).reverse().reduce((e4, r3) => e4 ? t3(e4, r3.encode) : r3.encode, void 0), decode: e3.reduce((e4, r3) => e4 ? t3(e4, r3.decode) : r3.decode, void 0) };
  }
  function o2(e3) {
    return { encode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0]) throw new Error("alphabet.encode input should be an array of numbers");
      return t3.map((t4) => {
        if (r2(t4), t4 < 0 || t4 >= e3.length) throw new Error(`Digit index outside alphabet: ${t4} (alphabet: ${e3.length})`);
        return e3[t4];
      });
    }, decode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0]) throw new Error("alphabet.decode input should be array of strings");
      return t3.map((t4) => {
        if ("string" != typeof t4) throw new Error(`alphabet.decode: not string element=${t4}`);
        const r3 = e3.indexOf(t4);
        if (-1 === r3) throw new Error(`Unknown letter: "${t4}". Allowed: ${e3}`);
        return r3;
      });
    } };
  }
  function s2(e3 = "") {
    if ("string" != typeof e3) throw new Error("join separator should be string");
    return { encode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0]) throw new Error("join.encode input should be array of strings");
      for (let e4 of t3) if ("string" != typeof e4) throw new Error(`join.encode: non-string input=${e4}`);
      return t3.join(e3);
    }, decode: (t3) => {
      if ("string" != typeof t3) throw new Error("join.decode input should be string");
      return t3.split(e3);
    } };
  }
  function i2(e3, t3 = "=") {
    if (r2(e3), "string" != typeof t3) throw new Error("padding chr should be string");
    return { encode(r3) {
      if (!Array.isArray(r3) || r3.length && "string" != typeof r3[0]) throw new Error("padding.encode input should be array of strings");
      for (let e4 of r3) if ("string" != typeof e4) throw new Error(`padding.encode: non-string input=${e4}`);
      for (; r3.length * e3 % 8; ) r3.push(t3);
      return r3;
    }, decode(r3) {
      if (!Array.isArray(r3) || r3.length && "string" != typeof r3[0]) throw new Error("padding.encode input should be array of strings");
      for (let e4 of r3) if ("string" != typeof e4) throw new Error(`padding.decode: non-string input=${e4}`);
      let n3 = r3.length;
      if (n3 * e3 % 8) throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n3 > 0 && r3[n3 - 1] === t3; n3--) if (!((n3 - 1) * e3 % 8)) throw new Error("Invalid padding: string has too much padding");
      return r3.slice(0, n3);
    } };
  }
  function a2(e3) {
    if ("function" != typeof e3) throw new Error("normalize fn should be function");
    return { encode: (e4) => e4, decode: (t3) => e3(t3) };
  }
  function c2(e3, t3, n3) {
    if (t3 < 2) throw new Error(`convertRadix: wrong from=${t3}, base cannot be less than 2`);
    if (n3 < 2) throw new Error(`convertRadix: wrong to=${n3}, base cannot be less than 2`);
    if (!Array.isArray(e3)) throw new Error("convertRadix: data should be array");
    if (!e3.length) return [];
    let o3 = 0;
    const s3 = [], i3 = Array.from(e3);
    for (i3.forEach((e4) => {
      if (r2(e4), e4 < 0 || e4 >= t3) throw new Error(`Wrong integer: ${e4}`);
    }); ; ) {
      let e4 = 0, r3 = true;
      for (let s4 = o3; s4 < i3.length; s4++) {
        const a3 = i3[s4], c3 = t3 * e4 + a3;
        if (!Number.isSafeInteger(c3) || t3 * e4 / t3 !== e4 || c3 - a3 != t3 * e4) throw new Error("convertRadix: carry overflow");
        if (e4 = c3 % n3, i3[s4] = Math.floor(c3 / n3), !Number.isSafeInteger(i3[s4]) || i3[s4] * n3 + e4 !== c3) throw new Error("convertRadix: carry overflow");
        r3 && (i3[s4] ? r3 = false : o3 = s4);
      }
      if (s3.push(e4), r3) break;
    }
    for (let t4 = 0; t4 < e3.length - 1 && 0 === e3[t4]; t4++) s3.push(0);
    return s3.reverse();
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.bytes = t2.stringToBytes = t2.str = t2.bytesToString = t2.hex = t2.utf8 = t2.bech32m = t2.bech32 = t2.base58check = t2.base58xmr = t2.base58xrp = t2.base58flickr = t2.base58 = t2.base64url = t2.base64 = t2.base32crockford = t2.base32hex = t2.base32 = t2.base16 = t2.utils = t2.assertNumber = void 0, t2.assertNumber = r2;
  const h3 = (e3, t3) => t3 ? h3(t3, e3 % t3) : e3, l2 = (e3, t3) => e3 + (t3 - h3(e3, t3));
  function u2(e3, t3, n3, o3) {
    if (!Array.isArray(e3)) throw new Error("convertRadix2: data should be array");
    if (t3 <= 0 || t3 > 32) throw new Error(`convertRadix2: wrong from=${t3}`);
    if (n3 <= 0 || n3 > 32) throw new Error(`convertRadix2: wrong to=${n3}`);
    if (l2(t3, n3) > 32) throw new Error(`convertRadix2: carry overflow from=${t3} to=${n3} carryBits=${l2(t3, n3)}`);
    let s3 = 0, i3 = 0;
    const a3 = 2 ** n3 - 1, c3 = [];
    for (const o4 of e3) {
      if (r2(o4), o4 >= 2 ** t3) throw new Error(`convertRadix2: invalid data word=${o4} from=${t3}`);
      if (s3 = s3 << t3 | o4, i3 + t3 > 32) throw new Error(`convertRadix2: carry overflow pos=${i3} from=${t3}`);
      for (i3 += t3; i3 >= n3; i3 -= n3) c3.push((s3 >> i3 - n3 & a3) >>> 0);
      s3 &= 2 ** i3 - 1;
    }
    if (s3 = s3 << n3 - i3 & a3, !o3 && i3 >= t3) throw new Error("Excess padding");
    if (!o3 && s3) throw new Error(`Non-zero padding: ${s3}`);
    return o3 && i3 > 0 && c3.push(s3 >>> 0), c3;
  }
  function f3(e3) {
    return r2(e3), { encode: (t3) => {
      if (!(t3 instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
      return c2(Array.from(t3), 256, e3);
    }, decode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0]) throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(c2(t3, e3, 256));
    } };
  }
  function d3(e3, t3 = false) {
    if (r2(e3), e3 <= 0 || e3 > 32) throw new Error("radix2: bits should be in (0..32]");
    if (l2(8, e3) > 32 || l2(e3, 8) > 32) throw new Error("radix2: carry overflow");
    return { encode: (r3) => {
      if (!(r3 instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
      return u2(Array.from(r3), 8, e3, !t3);
    }, decode: (r3) => {
      if (!Array.isArray(r3) || r3.length && "number" != typeof r3[0]) throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(u2(r3, e3, 8, t3));
    } };
  }
  function p3(e3) {
    if ("function" != typeof e3) throw new Error("unsafeWrapper fn should be function");
    return function(...t3) {
      try {
        return e3.apply(null, t3);
      } catch (e4) {
      }
    };
  }
  function w3(e3, t3) {
    if (r2(e3), "function" != typeof t3) throw new Error("checksum fn should be function");
    return { encode(r3) {
      if (!(r3 instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
      const n3 = t3(r3).slice(0, e3), o3 = new Uint8Array(r3.length + e3);
      return o3.set(r3), o3.set(n3, r3.length), o3;
    }, decode(r3) {
      if (!(r3 instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
      const n3 = r3.slice(0, -e3), o3 = t3(n3).slice(0, e3), s3 = r3.slice(-e3);
      for (let t4 = 0; t4 < e3; t4++) if (o3[t4] !== s3[t4]) throw new Error("Invalid checksum");
      return n3;
    } };
  }
  t2.utils = { alphabet: o2, chain: n2, checksum: w3, radix: f3, radix2: d3, join: s2, padding: i2 }, t2.base16 = n2(d3(4), o2("0123456789ABCDEF"), s2("")), t2.base32 = n2(d3(5), o2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), i2(5), s2("")), t2.base32hex = n2(d3(5), o2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), i2(5), s2("")), t2.base32crockford = n2(d3(5), o2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), s2(""), a2((e3) => e3.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), t2.base64 = n2(d3(6), o2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), i2(6), s2("")), t2.base64url = n2(d3(6), o2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), i2(6), s2(""));
  const y3 = (e3) => n2(f3(58), o2(e3), s2(""));
  t2.base58 = y3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), t2.base58flickr = y3("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), t2.base58xrp = y3("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const m3 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  t2.base58xmr = { encode(e3) {
    let r3 = "";
    for (let n3 = 0; n3 < e3.length; n3 += 8) {
      const o3 = e3.subarray(n3, n3 + 8);
      r3 += t2.base58.encode(o3).padStart(m3[o3.length], "1");
    }
    return r3;
  }, decode(e3) {
    let r3 = [];
    for (let n3 = 0; n3 < e3.length; n3 += 11) {
      const o3 = e3.slice(n3, n3 + 11), s3 = m3.indexOf(o3.length), i3 = t2.base58.decode(o3);
      for (let e4 = 0; e4 < i3.length - s3; e4++) if (0 !== i3[e4]) throw new Error("base58xmr: wrong padding");
      r3 = r3.concat(Array.from(i3.slice(i3.length - s3)));
    }
    return Uint8Array.from(r3);
  } }, t2.base58check = (e3) => n2(w3(4, (t3) => e3(e3(t3))), t2.base58);
  const g3 = n2(o2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), s2("")), b3 = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function v3(e3) {
    const t3 = e3 >> 25;
    let r3 = (33554431 & e3) << 5;
    for (let e4 = 0; e4 < b3.length; e4++) 1 == (t3 >> e4 & 1) && (r3 ^= b3[e4]);
    return r3;
  }
  function E3(e3, t3, r3 = 1) {
    const n3 = e3.length;
    let o3 = 1;
    for (let t4 = 0; t4 < n3; t4++) {
      const r4 = e3.charCodeAt(t4);
      if (r4 < 33 || r4 > 126) throw new Error(`Invalid prefix (${e3})`);
      o3 = v3(o3) ^ r4 >> 5;
    }
    o3 = v3(o3);
    for (let t4 = 0; t4 < n3; t4++) o3 = v3(o3) ^ 31 & e3.charCodeAt(t4);
    for (let e4 of t3) o3 = v3(o3) ^ e4;
    for (let e4 = 0; e4 < 6; e4++) o3 = v3(o3);
    return o3 ^= r3, g3.encode(u2([o3 % 2 ** 30], 30, 5, false));
  }
  function x3(e3) {
    const t3 = "bech32" === e3 ? 1 : 734539939, r3 = d3(5), n3 = r3.decode, o3 = r3.encode, s3 = p3(n3);
    function i3(e4, r4 = 90) {
      if ("string" != typeof e4) throw new Error("bech32.decode input should be string, not " + typeof e4);
      if (e4.length < 8 || false !== r4 && e4.length > r4) throw new TypeError(`Wrong string length: ${e4.length} (${e4}). Expected (8..${r4})`);
      const n4 = e4.toLowerCase();
      if (e4 !== n4 && e4 !== e4.toUpperCase()) throw new Error("String must be lowercase or uppercase");
      const o4 = (e4 = n4).lastIndexOf("1");
      if (0 === o4 || -1 === o4) throw new Error('Letter "1" must be present between prefix and data only');
      const s4 = e4.slice(0, o4), i4 = e4.slice(o4 + 1);
      if (i4.length < 6) throw new Error("Data must be at least 6 characters long");
      const a3 = g3.decode(i4).slice(0, -6), c3 = E3(s4, a3, t3);
      if (!i4.endsWith(c3)) throw new Error(`Invalid checksum in ${e4}: expected "${c3}"`);
      return { prefix: s4, words: a3 };
    }
    return { encode: function(e4, r4, n4 = 90) {
      if ("string" != typeof e4) throw new Error("bech32.encode prefix should be string, not " + typeof e4);
      if (!Array.isArray(r4) || r4.length && "number" != typeof r4[0]) throw new Error("bech32.encode words should be array of numbers, not " + typeof r4);
      const o4 = e4.length + 7 + r4.length;
      if (false !== n4 && o4 > n4) throw new TypeError(`Length ${o4} exceeds limit ${n4}`);
      return `${e4 = e4.toLowerCase()}1${g3.encode(r4)}${E3(e4, r4, t3)}`;
    }, decode: i3, decodeToBytes: function(e4) {
      const { prefix: t4, words: r4 } = i3(e4, false);
      return { prefix: t4, words: r4, bytes: n3(r4) };
    }, decodeUnsafe: p3(i3), fromWords: n3, fromWordsUnsafe: s3, toWords: o3 };
  }
  t2.bech32 = x3("bech32"), t2.bech32m = x3("bech32m"), t2.utf8 = { encode: (e3) => new TextDecoder().decode(e3), decode: (e3) => new TextEncoder().encode(e3) }, t2.hex = n2(d3(4), o2("0123456789abcdef"), s2(""), a2((e3) => {
    if ("string" != typeof e3 || e3.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e3} with length ${e3.length}`);
    return e3.toLowerCase();
  }));
  const A3 = { utf8: t2.utf8, hex: t2.hex, base16: t2.base16, base32: t2.base32, base64: t2.base64, base64url: t2.base64url, base58: t2.base58, base58xmr: t2.base58xmr }, k3 = `Invalid encoding type. Available types: ${Object.keys(A3).join(", ")}`;
  t2.bytesToString = (e3, t3) => {
    if ("string" != typeof e3 || !A3.hasOwnProperty(e3)) throw new TypeError(k3);
    if (!(t3 instanceof Uint8Array)) throw new TypeError("bytesToString() expects Uint8Array");
    return A3[e3].encode(t3);
  }, t2.str = t2.bytesToString, t2.stringToBytes = (e3, t3) => {
    if (!A3.hasOwnProperty(e3)) throw new TypeError(k3);
    if ("string" != typeof t3) throw new TypeError("stringToBytes() expects string");
    return A3[e3].decode(t3);
  }, t2.bytes = t2.stringToBytes;
}, e(t = { exports: {} }, t.exports), t.exports);
var { bech32: n, hex: o, utf8: s } = r;
var i = { bech32: "bc", pubKeyHash: 0, scriptHash: 5, validWitnessVersions: [0] };
var a = { bech32: "tb", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0] };
var c = { bech32: "tbs", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0] };
var h = { bech32: "bcrt", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0] };
var l = { bech32: "sb", pubKeyHash: 63, scriptHash: 123, validWitnessVersions: [0] };
var u = ["option_data_loss_protect", "initial_routing_sync", "option_upfront_shutdown_script", "gossip_queries", "var_onion_optin", "gossip_queries_ex", "option_static_remotekey", "payment_secret", "basic_mpp", "option_support_large_channel"];
var f = { m: BigInt(1e3), u: BigInt(1e6), n: BigInt(1e9), p: BigInt(1e12) };
var d = BigInt("2100000000000000000");
var p = BigInt(1e11);
var w = { payment_hash: 1, payment_secret: 16, description: 13, payee: 19, description_hash: 23, expiry: 6, min_final_cltv_expiry: 24, fallback_address: 9, route_hint: 3, feature_bits: 5, metadata: 27 };
var y = {};
for (let e2 = 0, t2 = Object.keys(w); e2 < t2.length; e2++) {
  const r2 = t2[e2], n2 = w[t2[e2]].toString();
  y[n2] = r2;
}
var m = { 1: (e2) => o.encode(n.fromWordsUnsafe(e2)), 16: (e2) => o.encode(n.fromWordsUnsafe(e2)), 13: (e2) => s.encode(n.fromWordsUnsafe(e2)), 19: (e2) => o.encode(n.fromWordsUnsafe(e2)), 23: (e2) => o.encode(n.fromWordsUnsafe(e2)), 27: (e2) => o.encode(n.fromWordsUnsafe(e2)), 6: b, 24: b, 3: function(e2) {
  const t2 = [];
  let r2, s2, i2, a2, c2, h3 = n.fromWordsUnsafe(e2);
  for (; h3.length > 0; ) r2 = o.encode(h3.slice(0, 33)), s2 = o.encode(h3.slice(33, 41)), i2 = parseInt(o.encode(h3.slice(41, 45)), 16), a2 = parseInt(o.encode(h3.slice(45, 49)), 16), c2 = parseInt(o.encode(h3.slice(49, 51)), 16), h3 = h3.slice(51), t2.push({ pubkey: r2, short_channel_id: s2, fee_base_msat: i2, fee_proportional_millionths: a2, cltv_expiry_delta: c2 });
  return t2;
}, 5: function(e2) {
  const t2 = e2.slice().reverse().map((e3) => [!!(1 & e3), !!(2 & e3), !!(4 & e3), !!(8 & e3), !!(16 & e3)]).reduce((e3, t3) => e3.concat(t3), []);
  for (; t2.length < 2 * u.length; ) t2.push(false);
  const r2 = {};
  u.forEach((e3, n3) => {
    let o2;
    o2 = t2[2 * n3] ? "required" : t2[2 * n3 + 1] ? "supported" : "unsupported", r2[e3] = o2;
  });
  const n2 = t2.slice(2 * u.length);
  return r2.extra_bits = { start_bit: 2 * u.length, bits: n2, has_required: n2.reduce((e3, t3, r3) => r3 % 2 != 0 ? e3 || false : e3 || t3, false) }, r2;
} };
function g(e2) {
  return (t2) => ({ tagCode: parseInt(e2), words: n.encode("unknown", t2, Number.MAX_SAFE_INTEGER) });
}
function b(e2) {
  return e2.reverse().reduce((e3, t2, r2) => e3 + t2 * Math.pow(32, r2), 0);
}
var v = (e2) => Uint8Array.from(e2.match(/.{1,2}/g).map((e3) => parseInt(e3, 16)));
var E = (e2) => {
  if (!e2) return null;
  try {
    const t2 = function(e3, t3) {
      if ("string" != typeof e3) throw new Error("Lightning Payment Request must be string");
      if ("ln" !== e3.slice(0, 2).toLowerCase()) throw new Error("Not a proper lightning payment request");
      const r3 = [], s3 = n.decode(e3, Number.MAX_SAFE_INTEGER);
      e3 = e3.toLowerCase();
      const u3 = s3.prefix;
      let v4 = s3.words, E4 = e3.slice(u3.length + 1), x4 = v4.slice(-104);
      v4 = v4.slice(0, -104);
      let A4 = u3.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
      if (A4 && !A4[2] && (A4 = u3.match(/^ln(\S+)$/)), !A4) throw new Error("Not a proper lightning payment request");
      r3.push({ name: "lightning_network", letters: "ln" });
      const k4 = A4[1];
      let $4;
      switch (k4) {
        case i.bech32:
          $4 = i;
          break;
        case a.bech32:
          $4 = a;
          break;
        case c.bech32:
          $4 = c;
          break;
        case h.bech32:
          $4 = h;
          break;
        case l.bech32:
          $4 = l;
      }
      if (!$4 || $4.bech32 !== k4) throw new Error("Unknown coin bech32 prefix");
      r3.push({ name: "coin_network", letters: k4, value: $4 });
      const _3 = A4[2];
      let U3;
      _3 ? (U3 = function(e4, t4) {
        let r4, n2;
        if (e4.slice(-1).match(/^[munp]$/)) r4 = e4.slice(-1), n2 = e4.slice(0, -1);
        else {
          if (e4.slice(-1).match(/^[^munp0-9]$/)) throw new Error("Not a valid multiplier for the amount");
          n2 = e4;
        }
        if (!n2.match(/^\d+$/)) throw new Error("Not a valid human readable amount");
        const o2 = BigInt(n2), s4 = r4 ? o2 * p / f[r4] : o2 * p;
        if ("p" === r4 && o2 % BigInt(10) !== BigInt(0) || s4 > d) throw new Error("Amount is outside of valid range");
        return s4.toString();
      }(_3 + A4[3]), r3.push({ name: "amount", letters: A4[2] + A4[3], value: U3 })) : U3 = null, r3.push({ name: "separator", letters: "1" });
      const L3 = b(v4.slice(0, 7));
      let D3, N3, I3, S3;
      for (v4 = v4.slice(7), r3.push({ name: "timestamp", letters: E4.slice(0, 7), value: L3 }), E4 = E4.slice(7); v4.length > 0; ) {
        const e4 = v4[0].toString();
        D3 = y[e4] || "unknown_tag", N3 = m[e4] || g(e4), v4 = v4.slice(1), I3 = b(v4.slice(0, 2)), v4 = v4.slice(2), S3 = v4.slice(0, I3), v4 = v4.slice(I3), r3.push({ name: D3, tag: E4[0], letters: E4.slice(0, 3 + I3), value: N3(S3) }), E4 = E4.slice(3 + I3);
      }
      r3.push({ name: "signature", letters: E4.slice(0, 104), value: o.encode(n.fromWordsUnsafe(x4)) }), E4 = E4.slice(104), r3.push({ name: "checksum", letters: E4 });
      let R3 = { paymentRequest: e3, sections: r3, get expiry() {
        let e4 = r3.find((e5) => "expiry" === e5.name);
        if (e4) return P3("timestamp") + e4.value;
      }, get route_hints() {
        return r3.filter((e4) => "route_hint" === e4.name).map((e4) => e4.value);
      } };
      for (let e4 in w) "route_hint" !== e4 && Object.defineProperty(R3, e4, { get: () => P3(e4) });
      return R3;
      function P3(e4) {
        let t4 = r3.find((t5) => t5.name === e4);
        return t4 ? t4.value : void 0;
      }
    }(e2);
    if (!t2 || !t2.sections) return null;
    const r2 = t2.sections.find((e3) => "payment_hash" === e3.name);
    if ("payment_hash" !== (null == r2 ? void 0 : r2.name) || !r2.value) return null;
    const s2 = r2.value;
    let u2 = 0;
    const v3 = t2.sections.find((e3) => "amount" === e3.name);
    "amount" === (null == v3 ? void 0 : v3.name) && v3.value && (u2 = parseInt(v3.value) / 1e3);
    const E3 = t2.sections.find((e3) => "timestamp" === e3.name);
    if ("timestamp" !== (null == E3 ? void 0 : E3.name) || !E3.value) return null;
    const x3 = E3.value;
    let A3;
    const k3 = t2.sections.find((e3) => "expiry" === e3.name);
    "expiry" === (null == k3 ? void 0 : k3.name) && (A3 = k3.value);
    const $3 = t2.sections.find((e3) => "description" === e3.name);
    return { paymentHash: s2, satoshi: u2, timestamp: x3, expiry: A3, description: "description" === (null == $3 ? void 0 : $3.name) ? null == $3 ? void 0 : $3.value : void 0 };
  } catch (e3) {
    return null;
  }
};
function x(e2, t2 = true) {
  if (e2.destroyed) throw new Error("Hash instance has been destroyed");
  if (t2 && e2.finished) throw new Error("Hash#digest() has already been called");
}
var A = (e2) => e2 instanceof Uint8Array;
var k = (e2) => new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
var $ = (e2, t2) => e2 << 32 - t2 | e2 >>> t2;
if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw new Error("Non little-endian hardware is not supported");
var _ = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function U(e2) {
  if (!A(e2)) throw new Error("Uint8Array expected");
  let t2 = "";
  for (let r2 = 0; r2 < e2.length; r2++) t2 += _[e2[r2]];
  return t2;
}
function L(e2) {
  if ("string" == typeof e2 && (e2 = function(e3) {
    if ("string" != typeof e3) throw new Error("utf8ToBytes expected string, got " + typeof e3);
    return new Uint8Array(new TextEncoder().encode(e3));
  }(e2)), !A(e2)) throw new Error("expected Uint8Array, got " + typeof e2);
  return e2;
}
var D = class {
  clone() {
    return this._cloneInto();
  }
};
function N(e2) {
  const t2 = (t3) => e2().update(L(t3)).digest(), r2 = e2();
  return t2.outputLen = r2.outputLen, t2.blockLen = r2.blockLen, t2.create = () => e2(), t2;
}
var I = class extends D {
  constructor(e2, t2, r2, n2) {
    super(), this.blockLen = e2, this.outputLen = t2, this.padOffset = r2, this.isLE = n2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e2), this.view = k(this.buffer);
  }
  update(e2) {
    x(this);
    const { view: t2, buffer: r2, blockLen: n2 } = this, o2 = (e2 = L(e2)).length;
    for (let s2 = 0; s2 < o2; ) {
      const i2 = Math.min(n2 - this.pos, o2 - s2);
      if (i2 !== n2) r2.set(e2.subarray(s2, s2 + i2), this.pos), this.pos += i2, s2 += i2, this.pos === n2 && (this.process(t2, 0), this.pos = 0);
      else {
        const t3 = k(e2);
        for (; n2 <= o2 - s2; s2 += n2) this.process(t3, s2);
      }
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    x(this), function(e3, t3) {
      !function(e4, ...t4) {
        if (!(e4 instanceof Uint8Array)) throw new Error("Expected Uint8Array");
        if (t4.length > 0 && !t4.includes(e4.length)) throw new Error(`Expected Uint8Array of length ${t4}, not of length=${e4.length}`);
      }(e3);
      const r3 = t3.outputLen;
      if (e3.length < r3) throw new Error(`digestInto() expects output buffer of length at least ${r3}`);
    }(e2, this), this.finished = true;
    const { buffer: t2, view: r2, blockLen: n2, isLE: o2 } = this;
    let { pos: s2 } = this;
    t2[s2++] = 128, this.buffer.subarray(s2).fill(0), this.padOffset > n2 - s2 && (this.process(r2, 0), s2 = 0);
    for (let e3 = s2; e3 < n2; e3++) t2[e3] = 0;
    !function(e3, t3, r3, n3) {
      if ("function" == typeof e3.setBigUint64) return e3.setBigUint64(t3, r3, n3);
      const o3 = BigInt(32), s3 = BigInt(4294967295), i3 = Number(r3 >> o3 & s3), a3 = Number(r3 & s3), c3 = n3 ? 0 : 4;
      e3.setUint32(t3 + (n3 ? 4 : 0), i3, n3), e3.setUint32(t3 + c3, a3, n3);
    }(r2, n2 - 8, BigInt(8 * this.length), o2), this.process(r2, 0);
    const i2 = k(e2), a2 = this.outputLen;
    if (a2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c2 = a2 / 4, h3 = this.get();
    if (c2 > h3.length) throw new Error("_sha2: outputLen bigger than state");
    for (let e3 = 0; e3 < c2; e3++) i2.setUint32(4 * e3, h3[e3], o2);
  }
  digest() {
    const { buffer: e2, outputLen: t2 } = this;
    this.digestInto(e2);
    const r2 = e2.slice(0, t2);
    return this.destroy(), r2;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: t2, buffer: r2, length: n2, finished: o2, destroyed: s2, pos: i2 } = this;
    return e2.length = n2, e2.pos = i2, e2.finished = o2, e2.destroyed = s2, n2 % t2 && e2.buffer.set(r2), e2;
  }
};
var S = (e2, t2, r2) => e2 & t2 ^ e2 & r2 ^ t2 & r2;
var R = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var P = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var T = new Uint32Array(64);
var W = class extends I {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | P[0], this.B = 0 | P[1], this.C = 0 | P[2], this.D = 0 | P[3], this.E = 0 | P[4], this.F = 0 | P[5], this.G = 0 | P[6], this.H = 0 | P[7];
  }
  get() {
    const { A: e2, B: t2, C: r2, D: n2, E: o2, F: s2, G: i2, H: a2 } = this;
    return [e2, t2, r2, n2, o2, s2, i2, a2];
  }
  set(e2, t2, r2, n2, o2, s2, i2, a2) {
    this.A = 0 | e2, this.B = 0 | t2, this.C = 0 | r2, this.D = 0 | n2, this.E = 0 | o2, this.F = 0 | s2, this.G = 0 | i2, this.H = 0 | a2;
  }
  process(e2, t2) {
    for (let r3 = 0; r3 < 16; r3++, t2 += 4) T[r3] = e2.getUint32(t2, false);
    for (let e3 = 16; e3 < 64; e3++) {
      const t3 = T[e3 - 15], r3 = T[e3 - 2], n3 = $(t3, 7) ^ $(t3, 18) ^ t3 >>> 3, o3 = $(r3, 17) ^ $(r3, 19) ^ r3 >>> 10;
      T[e3] = o3 + T[e3 - 7] + n3 + T[e3 - 16] | 0;
    }
    let { A: r2, B: n2, C: o2, D: s2, E: i2, F: a2, G: c2, H: h3 } = this;
    for (let e3 = 0; e3 < 64; e3++) {
      const t3 = h3 + ($(i2, 6) ^ $(i2, 11) ^ $(i2, 25)) + ((l2 = i2) & a2 ^ ~l2 & c2) + R[e3] + T[e3] | 0, u2 = ($(r2, 2) ^ $(r2, 13) ^ $(r2, 22)) + S(r2, n2, o2) | 0;
      h3 = c2, c2 = a2, a2 = i2, i2 = s2 + t3 | 0, s2 = o2, o2 = n2, n2 = r2, r2 = t3 + u2 | 0;
    }
    var l2;
    r2 = r2 + this.A | 0, n2 = n2 + this.B | 0, o2 = o2 + this.C | 0, s2 = s2 + this.D | 0, i2 = i2 + this.E | 0, a2 = a2 + this.F | 0, c2 = c2 + this.G | 0, h3 = h3 + this.H | 0, this.set(r2, n2, o2, s2, i2, a2, c2, h3);
  }
  roundClean() {
    T.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var B = N(() => new W());
var j = class {
  constructor(e2) {
    var t2, r2, n2, o2;
    if (this.paymentRequest = void 0, this.paymentHash = void 0, this.preimage = void 0, this.verify = void 0, this.satoshi = void 0, this.expiry = void 0, this.timestamp = void 0, this.createdDate = void 0, this.expiryDate = void 0, this.description = void 0, this.successAction = void 0, this.paymentRequest = e2.pr, !this.paymentRequest) throw new Error("Invalid payment request");
    const s2 = E(this.paymentRequest);
    if (!s2) throw new Error("Failed to decode payment request");
    this.paymentHash = s2.paymentHash, this.satoshi = s2.satoshi, this.timestamp = s2.timestamp, this.expiry = s2.expiry, this.createdDate = new Date(1e3 * this.timestamp), this.expiryDate = this.expiry ? new Date(1e3 * (this.timestamp + this.expiry)) : void 0, this.description = null != (t2 = s2.description) ? t2 : null, this.verify = null != (r2 = e2.verify) ? r2 : null, this.preimage = null != (n2 = e2.preimage) ? n2 : null, this.successAction = null != (o2 = e2.successAction) ? o2 : null;
  }
  async isPaid() {
    if (this.preimage) return this.validatePreimage(this.preimage);
    if (this.verify) return await this.verifyPayment();
    throw new Error("Could not verify payment");
  }
  validatePreimage(e2) {
    if (!e2 || !this.paymentHash) return false;
    try {
      const t2 = U(B(v(e2)));
      return this.paymentHash === t2;
    } catch (e3) {
      return false;
    }
  }
  async verifyPayment() {
    try {
      if (!this.verify) throw new Error("LNURL verify not available");
      const e2 = await fetch(this.verify);
      if (!e2.ok) throw new Error(`Verification request failed: ${e2.status} ${e2.statusText}`);
      const t2 = await e2.json();
      return t2.preimage && (this.preimage = t2.preimage), t2.settled;
    } catch (e2) {
      return console.error("Failed to check LNURL-verify", e2), false;
    }
  }
  hasExpired() {
    const { expiryDate: e2 } = this;
    return !!e2 && e2.getTime() < Date.now();
  }
};
var H = (e2) => {
  if ("keysend" !== e2.tag) throw new Error("Invalid keysend params");
  if ("OK" !== e2.status) throw new Error("Keysend status not OK");
  if (!e2.pubkey) throw new Error("Pubkey does not exist");
  let t2, r2;
  return e2.customData && e2.customData[0] && (t2 = e2.customData[0].customKey, r2 = e2.customData[0].customValue), { destination: e2.pubkey, customKey: t2, customValue: r2 };
};
async function O({ satoshi: e2, comment: t2, p: r2, e: n2, relays: o2 }, s2 = {}) {
  const i2 = s2.nostr || globalThis.nostr;
  if (!i2) throw new Error("nostr option or window.nostr is not available");
  const a2 = [["relays", ...o2], ["amount", e2.toString()]];
  r2 && a2.push(["p", r2]), n2 && a2.push(["e", n2]);
  const c2 = { pubkey: await i2.getPublicKey(), created_at: Math.floor(Date.now() / 1e3), kind: 9734, tags: a2, content: null != t2 ? t2 : "" };
  return c2.id = F(c2), await i2.signEvent(c2);
}
function C(e2) {
  if ("string" != typeof e2.content) return false;
  if ("number" != typeof e2.created_at) return false;
  if (!Array.isArray(e2.tags)) return false;
  for (let t2 = 0; t2 < e2.tags.length; t2++) {
    const r2 = e2.tags[t2];
    if (!Array.isArray(r2)) return false;
    for (let e3 = 0; e3 < r2.length; e3++) if ("object" == typeof r2[e3]) return false;
  }
  return true;
}
function K(e2) {
  if (!C(e2)) throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, e2.pubkey, e2.created_at, e2.kind, e2.tags, e2.content]);
}
function F(e2) {
  return U(B(K(e2)));
}
function V(e2, t2) {
  let r2, n2;
  var o2, s2;
  return t2 && e2 && (r2 = null == (o2 = e2.names) ? void 0 : o2[t2], n2 = r2 ? null == (s2 = e2.relays) ? void 0 : s2[r2] : void 0), [e2, r2, n2];
}
var q = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/;
var z = (e2) => !!e2 && q.test(e2);
var M = ({ amount: e2, min: t2, max: r2 }) => e2 > 0 && e2 >= t2 && e2 <= r2;
var G = async (e2) => {
  if ("payRequest" !== e2.tag) throw new Error("Invalid pay service params");
  const t2 = (e2.callback + "").trim();
  if (!z(t2)) throw new Error("Callback must be a valid url");
  const r2 = Math.ceil(Number(e2.minSendable || 0)), n2 = Math.floor(Number(e2.maxSendable));
  if (!r2 || !n2 || r2 > n2) throw new Error("Invalid pay service params");
  let o2, s2;
  try {
    o2 = JSON.parse(e2.metadata + ""), s2 = U(B(e2.metadata + ""));
  } catch (e3) {
    o2 = [], s2 = U(B("[]"));
  }
  let i2 = "", a2 = "", c2 = "", h3 = "";
  for (let e3 = 0; e3 < o2.length; e3++) {
    const [t3, r3] = o2[e3];
    switch (t3) {
      case "text/plain":
        c2 = r3;
        break;
      case "text/identifier":
        h3 = r3;
        break;
      case "text/email":
        i2 = r3;
        break;
      case "image/png;base64":
      case "image/jpeg;base64":
        a2 = "data:" + t3 + "," + r3;
    }
  }
  const l2 = e2.payerData;
  let u2;
  try {
    u2 = new URL(t2).hostname;
  } catch (e3) {
  }
  return { callback: t2, fixed: r2 === n2, min: r2, max: n2, domain: u2, metadata: o2, metadataHash: s2, identifier: h3, email: i2, description: c2, image: a2, payerData: l2, commentAllowed: Number(e2.commentAllowed) || 0, rawData: e2, allowsNostr: e2.allowsNostr || false };
};
function J() {
  return J = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2) Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, J.apply(this, arguments);
}
var Z = async (e2, t2) => {
  const { boost: r2 } = e2;
  t2 || (t2 = {});
  const n2 = t2.webln || globalThis.webln;
  if (!n2) throw new Error("WebLN not available");
  if (!n2.keysend) throw new Error("Keysend not available in current WebLN provider");
  const o2 = e2.amount || Math.floor(r2.value_msat / 1e3), s2 = { destination: e2.destination, amount: o2, customRecords: { 7629169: JSON.stringify(r2) } };
  return e2.customKey && e2.customValue && (s2.customRecords[e2.customKey] = e2.customValue), await n2.enable(), await n2.keysend(s2);
};
var X = /^((?:[^<>()[\]\\.,;:\s@"]+(?:\.[^<>()[\]\\.,;:\s@"]+)*)|(?:".+"))@((?:\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(?:(?:[a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var Y = class {
  constructor(e2, t2) {
    this.address = void 0, this.options = void 0, this.username = void 0, this.domain = void 0, this.pubkey = void 0, this.lnurlpData = void 0, this.keysendData = void 0, this.nostrData = void 0, this.nostrPubkey = void 0, this.nostrRelays = void 0, this.webln = void 0, this.address = e2, this.options = { proxy: "https://api.getalby.com/lnurl" }, this.options = Object.assign(this.options, t2), this.parse(), this.webln = this.options.webln;
  }
  parse() {
    const e2 = X.exec(this.address.toLowerCase());
    e2 && (this.username = e2[1], this.domain = e2[2]);
  }
  getWebLN() {
    return this.webln || globalThis.webln;
  }
  async fetch() {
    return this.options.proxy ? this.fetchWithProxy() : this.fetchWithoutProxy();
  }
  async fetchWithProxy() {
    const e2 = await fetch(`${this.options.proxy}/lightning-address-details?${new URLSearchParams({ ln: this.address }).toString()}`);
    if (!e2.ok) throw new Error(`Failed to fetch lnurl info: ${e2.status} ${e2.statusText}`);
    const t2 = await e2.json();
    await this.parseLnUrlPayResponse(t2.lnurlp), this.parseKeysendResponse(t2.keysend), this.parseNostrResponse(t2.nostr);
  }
  async fetchWithoutProxy() {
    this.domain && this.username && await Promise.all([this.fetchLnurlData(), this.fetchKeysendData(), this.fetchNostrData()]);
  }
  async fetchLnurlData() {
    const e2 = await fetch(this.lnurlpUrl());
    if (e2.ok) {
      const t2 = await e2.json();
      await this.parseLnUrlPayResponse(t2);
    }
  }
  async fetchKeysendData() {
    const e2 = await fetch(this.keysendUrl());
    if (e2.ok) {
      const t2 = await e2.json();
      this.parseKeysendResponse(t2);
    }
  }
  async fetchNostrData() {
    const e2 = await fetch(this.nostrUrl());
    if (e2.ok) {
      const t2 = await e2.json();
      this.parseNostrResponse(t2);
    }
  }
  lnurlpUrl() {
    return `https://${this.domain}/.well-known/lnurlp/${this.username}`;
  }
  keysendUrl() {
    return `https://${this.domain}/.well-known/keysend/${this.username}`;
  }
  nostrUrl() {
    return `https://${this.domain}/.well-known/nostr.json?name=${this.username}`;
  }
  async generateInvoice(e2) {
    let t2;
    if (this.options.proxy) {
      const r3 = await fetch(`${this.options.proxy}/generate-invoice?${new URLSearchParams(J({ ln: this.address }, e2)).toString()}`);
      if (!r3.ok) throw new Error(`Failed to generate invoice: ${r3.status} ${r3.statusText}`);
      t2 = (await r3.json()).invoice;
    } else {
      if (!this.lnurlpData) throw new Error("No lnurlpData available. Please call fetch() first.");
      if (!this.lnurlpData.callback || !z(this.lnurlpData.callback)) throw new Error("Valid callback does not exist in lnurlpData");
      const r3 = new URL(this.lnurlpData.callback);
      r3.search = new URLSearchParams(e2).toString();
      const n3 = await fetch(r3.toString());
      if (!n3.ok) throw new Error(`Failed to generate invoice: ${n3.status} ${n3.statusText}`);
      t2 = await n3.json();
    }
    const r2 = t2 && t2.pr && t2.pr.toString();
    if (!r2) throw new Error("Invalid pay service invoice");
    const n2 = { pr: r2 };
    if (t2 && t2.verify && (n2.verify = t2.verify.toString()), t2 && t2.successAction && "object" == typeof t2.successAction) {
      const { tag: e3, message: r3, description: o2, url: s2 } = t2.successAction;
      "message" === e3 ? n2.successAction = { tag: e3, message: r3 } : "url" === e3 && (n2.successAction = { tag: e3, description: o2, url: s2 });
    }
    return new j(n2);
  }
  async requestInvoice(e2) {
    if (!this.lnurlpData) throw new Error("No lnurlpData available. Please call fetch() first.");
    const t2 = 1e3 * e2.satoshi, { commentAllowed: r2, min: n2, max: o2 } = this.lnurlpData;
    if (!M({ amount: t2, min: n2, max: o2 })) throw new Error("Invalid amount");
    if (e2.comment && r2 && r2 > 0 && e2.comment.length > r2) throw new Error(`The comment length must be ${r2} characters or fewer`);
    const s2 = { amount: t2.toString() };
    return e2.comment && (s2.comment = e2.comment), e2.payerdata && (s2.payerdata = JSON.stringify(e2.payerdata)), this.generateInvoice(s2);
  }
  async boost(e2, t2 = 0) {
    if (!this.keysendData) throw new Error("No keysendData available. Please call fetch() first.");
    const { destination: r2, customKey: n2, customValue: o2 } = this.keysendData, s2 = this.getWebLN();
    if (!s2) throw new Error("WebLN not available");
    return Z({ destination: r2, customKey: n2, customValue: o2, amount: t2, boost: e2 }, { webln: s2 });
  }
  async zapInvoice({ satoshi: e2, comment: t2, relays: r2, e: n2 }, o2 = {}) {
    if (!this.lnurlpData) throw new Error("No lnurlpData available. Please call fetch() first.");
    if (!this.nostrPubkey) throw new Error("Nostr Pubkey is missing");
    const s2 = this.nostrPubkey, i2 = 1e3 * e2, { allowsNostr: a2, min: c2, max: h3 } = this.lnurlpData;
    if (!M({ amount: i2, min: c2, max: h3 })) throw new Error("Invalid amount");
    if (!a2) throw new Error("Your provider does not support zaps");
    const l2 = await O({ satoshi: i2, comment: t2, p: s2, e: n2, relays: r2 }, o2), u2 = { amount: i2.toString(), nostr: JSON.stringify(l2) };
    return await this.generateInvoice(u2);
  }
  async zap(e2, t2 = {}) {
    const r2 = this.zapInvoice(e2, t2), n2 = this.getWebLN();
    if (!n2) throw new Error("WebLN not available");
    return await n2.enable(), n2.sendPayment((await r2).paymentRequest);
  }
  async parseLnUrlPayResponse(e2) {
    e2 && (this.lnurlpData = await G(e2));
  }
  parseKeysendResponse(e2) {
    e2 && (this.keysendData = H(e2));
  }
  parseNostrResponse(e2) {
    e2 && ([this.nostrData, this.nostrPubkey, this.nostrRelays] = V(e2, this.username));
  }
};
var ee = class {
  constructor(e2) {
    this.storage = void 0, this.storage = e2 || {};
  }
  getItem(e2) {
    return this.storage[e2];
  }
  setItem(e2, t2) {
    this.storage[e2] = t2;
  }
};
var ne = new ee();
var ie = async (e2) => {
  const t2 = "https://getalby.com/api/rates/" + e2.toLowerCase() + ".json", r2 = await fetch(t2);
  if (!r2.ok) throw new Error(`Failed to fetch rate: ${r2.status} ${r2.statusText}`);
  return (await r2.json()).rate_float / 1e8;
};
var ae = async ({ satoshi: e2, currency: t2 }) => {
  const r2 = await ie(t2);
  return Number(e2) * r2;
};
var ce = async ({ amount: e2, currency: t2 }) => {
  const r2 = await ie(t2);
  return Math.floor(Number(e2) / r2);
};
var he = async ({ satoshi: e2, currency: t2, locale: r2 }) => (r2 || (r2 = "en"), (await ae({ satoshi: e2, currency: t2 })).toLocaleString(r2, { style: "currency", currency: t2 }));
var le = { __proto__: null, getFiatBtcRate: ie, getFiatValue: ae, getSatoshiValue: ce, getFormattedFiatValue: he };

// node_modules/@getalby/sdk/dist/index.modern.js
function h2() {
  return h2 = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var i2 in n2) Object.prototype.hasOwnProperty.call(n2, i2) && (e2[i2] = n2[i2]);
    }
    return e2;
  }, h2.apply(this, arguments);
}
function d2(e2, t2) {
  if (null == e2) return {};
  var n2, i2, s2 = {}, o2 = Object.keys(e2);
  for (i2 = 0; i2 < o2.length; i2++) t2.indexOf(n2 = o2[i2]) >= 0 || (s2[n2] = e2[n2]);
  return s2;
}
var p2 = class {
  constructor() {
    this.events = {};
  }
  on(e2, t2) {
    this.events[e2] || (this.events[e2] = []), this.events[e2].push(t2);
  }
  off(e2, t2) {
    this.events[e2] && (this.events[e2] = this.events[e2].filter((e3) => e3 !== t2));
  }
  emit(e2, t2) {
    this.events[e2] && this.events[e2].forEach((e3) => e3(t2));
  }
};
function y2(e2) {
  return Object.entries(e2).map(([e3, t2]) => e3 && t2 ? `${e3}=${t2}` : "").filter((e3) => e3).join("&");
}
function w2(e2, t2) {
  return `Basic ${btoa(`${e2}:${t2}`)}`;
}
var m2 = { __proto__: null, buildQueryString: y2, basicAuthHeader: w2 };
var f2 = class extends Error {
  constructor(e2, t2, n2, i2) {
    let s2 = e2.toString();
    t2 && (s2 += ` ${t2}`), s2 += ": ", s2 += i2.message ? i2.message : JSON.stringify(i2), super(s2), this.status = void 0, this.statusText = void 0, this.headers = void 0, this.error = void 0, this.status = e2, this.statusText = t2, this.headers = n2, this.error = i2;
  }
};
var g2 = { __proto__: null, OAuthClient: class {
}, AuthClient: class {
}, AlbyResponseError: f2 };
var v2 = ["auth", "endpoint", "params", "request_body", "method", "max_retries", "base_url", "user_agent", "headers"];
var _2 = "https://api.getalby.com";
async function b2(e2, t2, n2 = 0) {
  const i2 = await fetch(e2, t2);
  if (429 === i2.status && n2 > 0) {
    const s2 = Number(i2.headers.get("x-rate-limit-reset")), o2 = Number(i2.headers.get("x-rate-limit-remaining")), r2 = 1e3 * s2 - Date.now();
    let a2 = 1e3;
    return 0 === o2 && (a2 = r2), await new Promise((e3) => setTimeout(e3, a2)), b2(e2, t2, n2 - 1);
  }
  return i2;
}
async function k2(e2) {
  let { auth: t2, endpoint: n2, params: i2 = {}, request_body: s2, method: o2, max_retries: r2, base_url: a2 = _2, user_agent: c2, headers: l2 } = e2, u2 = d2(e2, v2);
  const p3 = new URL(a2 + n2);
  p3.search = y2(i2);
  const w3 = "POST" === o2 && !!s2, m3 = t2 ? await t2.getAuthHeader(p3.href, o2) : void 0, g3 = await b2(p3.toString(), h2({ headers: h2({}, w3 ? { "Content-Type": "application/json; charset=utf-8" } : void 0, m3, l2, { "User-Agent": null != c2 ? c2 : "@getalby/sdk", "X-User-Agent": null != c2 ? c2 : "@getalby/sdk" }), method: o2, body: w3 ? JSON.stringify(s2) : void 0 }, u2), r2);
  if (!g3.ok) {
    const e3 = await g3.json();
    throw new f2(g3.status, g3.statusText, g3.headers, e3);
  }
  return g3;
}
async function E2(e2) {
  return (await k2(e2)).json();
}
var P2 = (e2) => e2.reduce((e3, t2) => e3 + t2.toString(16).padStart(2, "0"), "");
var T2 = ["expires_in"];
var N2 = ["token"];
function q2(e2) {
  const { expires_in: t2 } = e2;
  return h2({}, d2(e2, T2), !!t2 && { expires_at: Date.now() + 1e3 * t2 });
}
var x2 = class {
  constructor(e2) {
    this.bearer_token = void 0, this.bearer_token = e2;
  }
  getAuthHeader() {
    return { Authorization: `Bearer ${this.bearer_token}` };
  }
};
var R2 = { __proto__: null, OAuth2User: class {
  constructor(e2) {
    this.token = void 0, this.options = void 0, this.code_verifier = void 0, this.code_challenge = void 0, this._refreshAccessTokenPromise = void 0, this._tokenEvents = void 0, this._tokenEvents = new p2();
    const { token: t2 } = e2, n2 = d2(e2, N2);
    this.options = h2({ client_secret: "" }, n2), this.token = t2, this._refreshAccessTokenPromise = null;
  }
  on(e2, t2) {
    this._tokenEvents.on(e2, t2);
  }
  async refreshAccessToken() {
    var e2 = this;
    return this._refreshAccessTokenPromise || (this._refreshAccessTokenPromise = new Promise(async function(t2, n2) {
      try {
        var i2;
        const n3 = null == (i2 = e2.token) ? void 0 : i2.refresh_token, { client_id: s2, client_secret: o2, request_options: r2, user_agent: a2 } = e2.options;
        if (!s2) throw new Error("client_id is required");
        if (!n3) throw new Error("refresh_token is required");
        const c2 = q2(await E2(h2({}, r2, { endpoint: "/oauth/token", params: { client_id: s2, grant_type: "refresh_token", refresh_token: n3 }, user_agent: a2, method: "POST", headers: h2({}, null == r2 ? void 0 : r2.headers, { "Content-type": "application/x-www-form-urlencoded" }, { Authorization: w2(s2, o2) }) })));
        e2.token = c2, t2({ token: c2 }), e2._tokenEvents.emit("tokenRefreshed", e2.token);
      } catch (t3) {
        console.error(t3), n2(t3), e2._tokenEvents.emit("tokenRefreshFailed", t3);
      } finally {
        e2._refreshAccessTokenPromise = null;
      }
    })), this._refreshAccessTokenPromise;
  }
  isAccessTokenExpired() {
    var e2, t2;
    const n2 = null == (e2 = this.token) ? void 0 : e2.refresh_token, i2 = null == (t2 = this.token) ? void 0 : t2.expires_at;
    return !i2 || !!n2 && i2 <= Date.now() + 1e3;
  }
  async requestAccessToken(e2) {
    const { client_id: t2, client_secret: n2, callback: i2, request_options: s2, user_agent: o2 } = this.options, r2 = this.code_verifier;
    if (!t2) throw new Error("client_id is required");
    if (!n2 && !r2) throw new Error("either client_secret is required, or code should be generated using a challenge");
    if (!i2) throw new Error("callback is required");
    const a2 = { code: e2, grant_type: "authorization_code", code_verifier: r2, client_id: t2, redirect_uri: i2 }, c2 = q2(await E2(h2({}, s2, { endpoint: "/oauth/token", params: a2, user_agent: o2, method: "POST", headers: h2({}, null == s2 ? void 0 : s2.headers, { "Content-Type": "application/x-www-form-urlencoded" }, { Authorization: w2(t2, n2) }) })));
    return this.token = c2, { token: c2 };
  }
  async generateAuthURL(e2) {
    e2 || (e2 = {});
    const { client_id: t2, callback: n2, scopes: i2 } = this.options;
    if (!n2) throw new Error("callback required");
    if (!i2) throw new Error("scopes required");
    let s2;
    "S256" === e2.code_challenge_method ? (await this._generateS256Challenge(), s2 = "S256") : "plain" === e2.code_challenge_method && e2.code_challenge && (this.code_challenge = e2.code_challenge, this.code_verifier = e2.code_challenge, s2 = "plain");
    const o2 = this.code_challenge, r2 = new URL(e2.authorizeUrl || "https://getalby.com/oauth");
    return r2.search = y2(h2({}, e2, { client_id: t2, scope: i2.join(" "), response_type: "code", redirect_uri: n2, code_challenge_method: s2, code_challenge: o2 })), r2.toString();
  }
  async getAuthHeader() {
    var e2;
    if (null == (e2 = this.token) || !e2.access_token) throw new Error("access_token is required");
    return this.isAccessTokenExpired() && await this.refreshAccessToken(), { Authorization: `Bearer ${this.token.access_token}` };
  }
  async _generateS256Challenge() {
    const e2 = crypto.getRandomValues(new Uint8Array(64));
    this.code_verifier = P2(e2);
    const t2 = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(this.code_verifier)), n2 = new Uint8Array(t2);
    this.code_challenge = btoa(String.fromCharCode(...n2)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
}, OAuth2Bearer: x2 };
function S2(e2) {
  const t2 = {};
  return e2.recipient.customKey && e2.recipient.customValue && (t2[e2.recipient.customKey] = e2.recipient.customValue), t2[7629169] = JSON.stringify(e2.boostagram), { destination: e2.recipient.address, amount: e2.amount, custom_records: t2 };
}
var I2 = class {
  constructor(e2, t2) {
    this.auth = void 0, this.defaultRequestOptions = void 0, this.auth = "string" == typeof e2 ? new x2(e2) : e2, this.defaultRequestOptions = h2({}, t2, { user_agent: null == t2 ? void 0 : t2.user_agent });
  }
  accountBalance(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/balance", params: e2, method: "GET" }));
  }
  signMessage(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/signatures", request_body: e2, method: "POST" }));
  }
  accountSummary(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/user/summary", params: e2, method: "GET" }));
  }
  accountInformation(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/user/me", params: e2, method: "GET" }));
  }
  accountValue4Value(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/user/value4value", params: e2, method: "GET" }));
  }
  incomingInvoices(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices/incoming", params: e2, method: "GET" }));
  }
  outgoingInvoices(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices/outgoing", params: e2, method: "GET" }));
  }
  invoices(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices", params: e2, method: "GET" }));
  }
  getInvoice(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: `/invoices/${e2}`, method: "GET" }));
  }
  decodeInvoice(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: `/decode/bolt11/${e2}`, method: "GET" }));
  }
  createInvoice(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices", request_body: e2, method: "POST" }));
  }
  keysend(e2, t2) {
    let n2, i2;
    return Array.isArray(e2) ? (n2 = "/payments/keysend/multi", i2 = { keysends: e2.map((e3) => h2({}, e3, { custom_records: e3.customRecords })) }) : (n2 = "/payments/keysend", i2 = h2({}, e2, { custom_records: e2.customRecords })), E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: n2, request_body: i2, method: "POST" }));
  }
  sendPayment(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/payments/bolt11", request_body: e2, method: "POST" }));
  }
  sendBoostagram(e2, t2) {
    let n2, i2;
    return Array.isArray(e2) ? (n2 = "/payments/keysend/multi", i2 = { keysends: e2.map((e3) => S2(e3)) }) : (n2 = "/payments/keysend", i2 = S2(e2)), E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: n2, request_body: i2, method: "POST" }));
  }
  sendBoostagramToAlbyAccount(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/payments/keysend", request_body: { destination: "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3", custom_records: { 696969: e2.account }, amount: e2.amount, memo: e2.memo }, method: "POST" }));
  }
  createWebhookEndpoint(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/webhook_endpoints", request_body: e2, method: "POST" }));
  }
  deleteWebhookEndpoint(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: `/webhook_endpoints/${e2}`, method: "DELETE" }));
  }
  getSwapInfo(e2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, e2, { endpoint: "/swaps/info", method: "GET" }));
  }
  createSwap(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/swaps", method: "POST", request_body: e2 }));
  }
};
var A2 = { __proto__: null, auth: R2, types: g2, utils: m2, Client: I2 };
if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw new Error("Non little-endian hardware is not supported");
var U2 = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function O2(e2) {
  if (!(e2 instanceof Uint8Array)) throw new Error("Uint8Array expected");
  let t2 = "";
  for (let n2 = 0; n2 < e2.length; n2++) t2 += U2[e2[n2]];
  return t2;
}
function C2(e2) {
  if ("string" != typeof e2) throw new Error("hex string expected, got " + typeof e2);
  const t2 = e2.length;
  if (t2 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t2);
  const n2 = new Uint8Array(t2 / 2);
  for (let t3 = 0; t3 < n2.length; t3++) {
    const i2 = 2 * t3, s2 = e2.slice(i2, i2 + 2), o2 = Number.parseInt(s2, 16);
    if (Number.isNaN(o2) || o2 < 0) throw new Error("Invalid byte sequence");
    n2[t3] = o2;
  }
  return n2;
}
var M2 = class extends Error {
  constructor(e2, t2) {
    super(e2), this.code = void 0, this.code = t2;
  }
};
var W2 = class extends M2 {
};
var $2 = class extends M2 {
};
var F2 = class extends M2 {
};
var L2 = class extends F2 {
};
var K2 = class extends F2 {
};
var j2 = class extends M2 {
};
var J2 = class extends M2 {
};
var B2 = class extends M2 {
};
var H2 = class extends M2 {
};
var z2 = class extends M2 {
};
var D2 = class _D {
  static parseWalletConnectUrl(e2) {
    e2 = e2.replace("nostrwalletconnect://", "http://").replace("nostr+walletconnect://", "http://").replace("nostrwalletconnect:", "http://").replace("nostr+walletconnect:", "http://");
    const t2 = new URL(e2), n2 = t2.searchParams.get("relay");
    if (!n2) throw new Error("No relay URL found in connection string");
    const i2 = { walletPubkey: t2.host, relayUrl: n2 }, s2 = t2.searchParams.get("secret");
    s2 && (i2.secret = s2);
    const o2 = t2.searchParams.get("lud16");
    return o2 && (i2.lud16 = o2), i2;
  }
  constructor(n2) {
    this.relay = void 0, this.relayUrl = void 0, this.secret = void 0, this.lud16 = void 0, this.walletPubkey = void 0, this.options = void 0, this._encryptionType = void 0, n2 && n2.nostrWalletConnectUrl && (n2 = h2({}, _D.parseWalletConnectUrl(n2.nostrWalletConnectUrl), n2)), this.options = h2({}, n2 || {}), this.relayUrl = this.options.relayUrl, this.relay = new Relay(this.relayUrl), this.options.secret && (this.secret = this.options.secret.toLowerCase().startsWith("nsec") ? nip19_exports.decode(this.options.secret).data : this.options.secret), this.lud16 = this.options.lud16, this.walletPubkey = this.options.walletPubkey.toLowerCase().startsWith("npub") ? nip19_exports.decode(this.options.walletPubkey).data : this.options.walletPubkey, void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
  }
  get nostrWalletConnectUrl() {
    return this.getNostrWalletConnectUrl();
  }
  getNostrWalletConnectUrl(e2 = true) {
    let t2 = `nostr+walletconnect://${this.walletPubkey}?relay=${this.relayUrl}&pubkey=${this.publicKey}`;
    return e2 && (t2 = `${t2}&secret=${this.secret}`), t2;
  }
  get connected() {
    return this.relay.connected;
  }
  get publicKey() {
    if (!this.secret) throw new Error("Missing secret key");
    return getPublicKey(C2(this.secret));
  }
  get encryptionType() {
    if (!this._encryptionType) throw new Error("Missing encryption or version");
    return this._encryptionType;
  }
  getPublicKey() {
    return Promise.resolve(this.publicKey);
  }
  signEvent(e2) {
    if (!this.secret) throw new Error("Missing secret key");
    return Promise.resolve(finalizeEvent(e2, C2(this.secret)));
  }
  getEventHash(e2) {
    return getEventHash(e2);
  }
  close() {
    return this.relay.close();
  }
  async encrypt(e2, t2) {
    if (!this.secret) throw new Error("Missing secret");
    let n2;
    if ("nip04" === this.encryptionType) n2 = await nip04_exports.encrypt(this.secret, e2, t2);
    else {
      const i2 = nip44_exports.getConversationKey(C2(this.secret), e2);
      n2 = nip44_exports.encrypt(t2, i2);
    }
    return n2;
  }
  async decrypt(e2, t2) {
    if (!this.secret) throw new Error("Missing secret");
    let n2;
    if ("nip04" === this.encryptionType) n2 = await nip04_exports.decrypt(this.secret, e2, t2);
    else {
      const i2 = nip44_exports.getConversationKey(C2(this.secret), e2);
      n2 = nip44_exports.decrypt(t2, i2);
    }
    return n2;
  }
  static getAuthorizationUrl(e2, t2 = {}, n2) {
    if (e2.indexOf("/#/") > -1) throw new Error("hash router paths not supported");
    const i2 = new URL(e2);
    return t2.name && i2.searchParams.set("name", t2.name), i2.searchParams.set("pubkey", n2), t2.returnTo && i2.searchParams.set("return_to", t2.returnTo), t2.budgetRenewal && i2.searchParams.set("budget_renewal", t2.budgetRenewal), t2.expiresAt && i2.searchParams.set("expires_at", Math.floor(t2.expiresAt.getTime() / 1e3).toString()), t2.maxAmount && i2.searchParams.set("max_amount", t2.maxAmount.toString()), t2.requestMethods && i2.searchParams.set("request_methods", t2.requestMethods.join(" ")), t2.notificationTypes && i2.searchParams.set("notification_types", t2.notificationTypes.join(" ")), t2.isolated && i2.searchParams.set("isolated", "true"), t2.metadata && i2.searchParams.set("metadata", JSON.stringify(t2.metadata)), i2;
  }
  static fromAuthorizationUrl(e2, t2 = {}, i2) {
    i2 = i2 || O2(generateSecretKey()), t2.name || (t2.name = document.location.host);
    const s2 = this.getAuthorizationUrl(e2, t2, getPublicKey(C2(i2))), o2 = window.outerHeight / 2 + window.screenY - 300, r2 = window.outerWidth / 2 + window.screenX - 200;
    return new Promise((e3, t3) => {
      const n2 = window.open(s2.toString(), `${document.title} - Wallet Connect`, `height=600,width=400,top=${o2},left=${r2}`);
      if (!n2) return void t3(new Error("failed to execute window.open"));
      const a2 = (o3) => {
        const r3 = o3.data;
        r3 && "nwc:success" === r3.type && o3.origin === `${s2.protocol}//${s2.host}` && (r3.relayUrl || t3(new Error("no relayUrl in response")), r3.walletPubkey || t3(new Error("no walletPubkey in response")), e3(new _D({ relayUrl: r3.relayUrl, walletPubkey: r3.walletPubkey, secret: i2, lud16: r3.lud16 })), clearInterval(c2), window.removeEventListener("message", a2), n2 && n2.close());
      }, c2 = setInterval(() => {
        n2 && n2.closed && (clearInterval(c2), window.removeEventListener("message", a2), t3(new Error("Popup closed")));
      }, 500);
      window.addEventListener("message", a2);
    });
  }
  async getWalletServiceInfo() {
    var e2;
    await this._checkConnected();
    const t2 = await new Promise((e3, t3) => {
      const n3 = [], i3 = this.relay.subscribe([{ kinds: [13194], limit: 1, authors: [this.walletPubkey] }], { eoseTimeout: 1e4 });
      i3.onevent = (e4) => {
        n3.push(e4);
      }, i3.oneose = () => {
        i3.close(), e3(n3);
      };
    });
    if (!t2.length) throw new Error("no info event (kind 13194) returned from relay");
    const n2 = t2[0].content, i2 = t2[0].tags.find((e3) => "notifications" === e3[0]), s2 = t2[0].tags.find((e3) => "v" === e3[0]), o2 = t2[0].tags.find((e3) => "encryption" === e3[0]);
    let r2 = ["nip04"];
    return s2 && s2[1].includes("1.0") && r2.push("nip44_v2"), o2 && (r2 = o2[1].split(" ")), { encryptions: r2, capabilities: n2.split(/[ |,]/g), notifications: (null == i2 || null == (e2 = i2[1]) ? void 0 : e2.split(" ")) || [] };
  }
  async getInfo() {
    try {
      return await this.executeNip47Request("get_info", {}, (e2) => !!e2.methods, { replyTimeout: 1e4 });
    } catch (e2) {
      throw console.error("Failed to request get_info", e2), e2;
    }
  }
  async getBudget() {
    try {
      return await this.executeNip47Request("get_budget", {}, (e2) => void 0 !== e2, { replyTimeout: 1e4 });
    } catch (e2) {
      throw console.error("Failed to request get_budget", e2), e2;
    }
  }
  async getBalance() {
    try {
      return await this.executeNip47Request("get_balance", {}, (e2) => void 0 !== e2.balance, { replyTimeout: 1e4 });
    } catch (e2) {
      throw console.error("Failed to request get_balance", e2), e2;
    }
  }
  async payInvoice(e2) {
    try {
      return await this.executeNip47Request("pay_invoice", e2, (e3) => !!e3);
    } catch (e3) {
      throw console.error("Failed to request pay_invoice", e3), e3;
    }
  }
  async payKeysend(e2) {
    try {
      return await this.executeNip47Request("pay_keysend", e2, (e3) => !!e3.preimage);
    } catch (e3) {
      throw console.error("Failed to request pay_keysend", e3), e3;
    }
  }
  async signMessage(e2) {
    try {
      return await this.executeNip47Request("sign_message", e2, (t2) => t2.message === e2.message && !!t2.signature);
    } catch (e3) {
      throw console.error("Failed to request sign_message", e3), e3;
    }
  }
  async createConnection(e2) {
    try {
      return await this.executeNip47Request("create_connection", e2, (e3) => !!e3.wallet_pubkey);
    } catch (e3) {
      throw console.error("Failed to request create_connection", e3), e3;
    }
  }
  async multiPayInvoice(e2) {
    try {
      return { invoices: await this.executeMultiNip47Request("multi_pay_invoice", e2, e2.invoices.length, (e3) => !!e3.preimage), errors: [] };
    } catch (e3) {
      throw console.error("Failed to request multi_pay_invoice", e3), e3;
    }
  }
  async multiPayKeysend(e2) {
    try {
      return { keysends: await this.executeMultiNip47Request("multi_pay_keysend", e2, e2.keysends.length, (e3) => !!e3.preimage), errors: [] };
    } catch (e3) {
      throw console.error("Failed to request multi_pay_keysend", e3), e3;
    }
  }
  async makeInvoice(e2) {
    try {
      if (!e2.amount) throw new Error("No amount specified");
      return await this.executeNip47Request("make_invoice", e2, (e3) => !!e3.invoice);
    } catch (e3) {
      throw console.error("Failed to request make_invoice", e3), e3;
    }
  }
  async makeHoldInvoice(e2) {
    try {
      if (!e2.amount) throw new Error("No amount specified");
      if (!e2.payment_hash) throw new Error("No payment hash specified");
      return await this.executeNip47Request("make_hold_invoice", e2, (e3) => !!e3.invoice);
    } catch (e3) {
      throw console.error("Failed to request make_hold_invoice", e3), e3;
    }
  }
  async settleHoldInvoice(e2) {
    try {
      return await this.executeNip47Request("settle_hold_invoice", e2, (e3) => !!e3);
    } catch (e3) {
      throw console.error("Failed to request settle_hold_invoice", e3), e3;
    }
  }
  async cancelHoldInvoice(e2) {
    try {
      return await this.executeNip47Request("cancel_hold_invoice", e2, (e3) => !!e3);
    } catch (e3) {
      throw console.error("Failed to request cancel_hold_invoice", e3), e3;
    }
  }
  async lookupInvoice(e2) {
    try {
      return await this.executeNip47Request("lookup_invoice", e2, (e3) => !!e3.invoice);
    } catch (e3) {
      throw console.error("Failed to request lookup_invoice", e3), e3;
    }
  }
  async listTransactions(e2) {
    try {
      return await this.executeNip47Request("list_transactions", e2, (e3) => !!e3.transactions, { replyTimeout: 1e4 });
    } catch (e3) {
      throw console.error("Failed to request list_transactions", e3), e3;
    }
  }
  async subscribeNotifications(e2, t2) {
    var n2 = this;
    let i2, s2, o2, r2 = true;
    return async function() {
      for (; r2; ) {
        try {
          await n2._checkConnected(), await n2._selectEncryptionType(), o2 = n2.relay.subscribe([{ kinds: [..."nip04" === n2.encryptionType ? [23196] : [23197]], authors: [n2.walletPubkey], "#p": [n2.publicKey] }], {}), console.info("subscribed to relay"), o2.onevent = async function(i3) {
            const s3 = await n2.decrypt(n2.walletPubkey, i3.content);
            let o3;
            try {
              o3 = JSON.parse(s3);
            } catch (e3) {
              return void console.error("Failed to parse decrypted event content", e3);
            }
            o3.notification ? (!t2 || t2.indexOf(o3.notification_type) > -1) && e2(o3) : console.error("No notification in response", o3);
          }, await new Promise((e3) => {
            i2 = () => {
              e3();
            }, s2 = () => {
              console.info("relay disconnected"), null == i2 || i2();
            }, n2.relay.onclose = s2;
          }), void 0 !== s2 && (n2.relay.onclose = null);
        } catch (e3) {
          console.error("error subscribing to notifications", e3 || "unknown relay error");
        }
        r2 && await new Promise((e3) => setTimeout(e3, 1e3));
      }
    }(), () => {
      var e3;
      r2 = false, null == i2 || i2(), null == (e3 = o2) || e3.close();
    };
  }
  async executeNip47Request(e2, t2, n2, i2) {
    var s2 = this;
    return await this._checkConnected(), await this._selectEncryptionType(), new Promise((o2, r2) => {
      !async function() {
        const a2 = { method: e2, params: t2 }, c2 = await s2.encrypt(s2.walletPubkey, JSON.stringify(a2)), l2 = { kind: 23194, created_at: Math.floor(Date.now() / 1e3), tags: [["p", s2.walletPubkey], ["v", "nip44_v2" === s2.encryptionType ? "1.0" : "0.0"], ["encryption", s2.encryptionType]], content: c2 }, u2 = await s2.signEvent(l2), h3 = s2.relay.subscribe([{ kinds: [23195], authors: [s2.walletPubkey], "#e": [u2.id] }], {}), d3 = setTimeout(function() {
          h3.close(), r2(new K2(`reply timeout: event ${u2.id}`, "INTERNAL"));
        }, (null == i2 ? void 0 : i2.replyTimeout) || 6e4);
        h3.onevent = async function(e3) {
          clearTimeout(d3), h3.close();
          const t3 = await s2.decrypt(s2.walletPubkey, e3.content);
          let i3;
          try {
            i3 = JSON.parse(t3);
          } catch (e4) {
            return clearTimeout(d3), h3.close(), void r2(new J2("failed to deserialize response", "INTERNAL"));
          }
          var a3, c3;
          i3.result ? n2(i3.result) ? o2(i3.result) : (clearTimeout(d3), h3.close(), r2(new B2("response from NWC failed validation: " + JSON.stringify(i3.result), "INTERNAL"))) : (clearTimeout(d3), h3.close(), r2(new $2((null == (a3 = i3.error) ? void 0 : a3.message) || "unknown Error", (null == (c3 = i3.error) ? void 0 : c3.code) || "INTERNAL")));
        };
        const p3 = setTimeout(function() {
          h3.close(), r2(new L2(`publish timeout: ${u2.id}`, "INTERNAL"));
        }, (null == i2 ? void 0 : i2.publishTimeout) || 5e3);
        try {
          await s2.relay.publish(u2), clearTimeout(p3);
        } catch (e3) {
          clearTimeout(p3), r2(new j2(`failed to publish: ${e3}`, "INTERNAL"));
        }
      }();
    });
  }
  async executeMultiNip47Request(e2, t2, n2, i2, s2) {
    var o2 = this;
    await this._checkConnected(), await this._selectEncryptionType();
    const r2 = [];
    return new Promise((a2, c2) => {
      !async function() {
        const l2 = { method: e2, params: t2 }, u2 = await o2.encrypt(o2.walletPubkey, JSON.stringify(l2)), d3 = { kind: 23194, created_at: Math.floor(Date.now() / 1e3), tags: [["p", o2.walletPubkey], ["v", "nip44_v2" === o2.encryptionType ? "1.0" : "0.0"], ["encryption", o2.encryptionType]], content: u2 }, p3 = await o2.signEvent(d3), y3 = o2.relay.subscribe([{ kinds: [23195], authors: [o2.walletPubkey], "#e": [p3.id] }], {}), w3 = setTimeout(function() {
          y3.close(), c2(new K2(`reply timeout: event ${p3.id}`, "INTERNAL"));
        }, (null == s2 ? void 0 : s2.replyTimeout) || 6e4);
        y3.onevent = async function(e3) {
          const t3 = await o2.decrypt(o2.walletPubkey, e3.content);
          let s3;
          try {
            s3 = JSON.parse(t3);
          } catch (e4) {
            clearTimeout(w3), y3.close(), c2(new J2("failed to deserialize response", "INTERNAL"));
          }
          if (s3.result) {
            var l3;
            if (!i2(s3.result)) return clearTimeout(w3), y3.close(), void c2(new B2("Response from NWC failed validation: " + JSON.stringify(s3.result), "INTERNAL"));
            const t4 = null == (l3 = e3.tags.find((e4) => "d" === e4[0])) ? void 0 : l3[1];
            if (void 0 === t4) return clearTimeout(w3), y3.close(), void c2(new B2("No d tag found in response event", "INTERNAL"));
            r2.push(h2({}, s3.result, { dTag: t4 })), r2.length === n2 && (clearTimeout(w3), y3.close(), a2(r2));
          } else {
            var u3, d4;
            clearTimeout(w3), y3.close(), c2(new H2(null == (u3 = s3.error) ? void 0 : u3.message, null == (d4 = s3.error) ? void 0 : d4.code));
          }
        };
        const m3 = setTimeout(function() {
          y3.close(), c2(new L2(`Publish timeout: ${p3.id}`, "INTERNAL"));
        }, (null == s2 ? void 0 : s2.publishTimeout) || 5e3);
        try {
          await o2.relay.publish(p3), clearTimeout(m3);
        } catch (e3) {
          clearTimeout(m3), c2(new j2(`Failed to publish: ${e3}`, "INTERNAL"));
        }
      }();
    });
  }
  async _checkConnected() {
    if (!this.secret) throw new Error("Missing secret key");
    if (!this.relayUrl) throw new Error("Missing relay url");
    try {
      this.relay.connected || await this.relay.connect();
    } catch (e2) {
      throw console.error("failed to connect to relay", this.relayUrl), new W2("Failed to connect to " + this.relayUrl, "OTHER");
    }
  }
  async _selectEncryptionType() {
    if (!this._encryptionType) {
      const e2 = await this.getWalletServiceInfo(), t2 = this._findPreferredEncryptionType(e2.encryptions);
      if (!t2) throw new z2("no compatible encryption or version found between wallet and client", "UNSUPPORTED_ENCRYPTION");
      "nip04" === t2 && console.warn("NIP-04 encryption is about to be deprecated. Please upgrade your wallet service to use NIP-44 instead."), this._encryptionType = t2;
    }
  }
  _findPreferredEncryptionType(e2) {
    return e2.includes("nip44_v2") ? "nip44_v2" : e2.includes("nip04") ? "nip04" : null;
  }
};
var G2 = { get_info: "getInfo", get_balance: "getBalance", make_invoice: "makeInvoice", pay_invoice: "sendPayment", pay_keysend: "payKeysend", lookup_invoice: "lookupInvoice", list_transactions: "listTransactions", multi_pay_invoice: "sendMultiPayment", multi_pay_keysend: "multiKeysend", sign_message: "signMessage" };
var V2 = class _V {
  get options() {
    return this.client.options;
  }
  static async fromAuthorizationUrl(e2, t2 = {}, n2) {
    const i2 = await D2.fromAuthorizationUrl(e2, t2, n2);
    return new _V({ client: i2 });
  }
  constructor(e2) {
    this._enabled = false, this.client = void 0, this.subscribers = void 0, this.client = (null == e2 ? void 0 : e2.client) || new D2(e2), this.subscribers = {};
  }
  on(e2, t2) {
    this.subscribers[e2] = t2;
  }
  notify(e2, t2) {
    const n2 = this.subscribers[e2];
    n2 && n2(t2);
  }
  getPublicKey() {
    return this.client.getPublicKey();
  }
  signEvent(e2) {
    return this.client.signEvent(e2);
  }
  async enable() {
    this._enabled = true;
  }
  close() {
    return this.client.close();
  }
  async getInfo() {
    await this.checkEnabled();
    const e2 = ["lightning", "nostr"], t2 = "Alby JS SDK";
    try {
      const n2 = await this.client.getInfo(), i2 = { methods: n2.methods.map((e3) => G2[e3]), node: { alias: n2.alias, pubkey: n2.pubkey, color: n2.color }, supports: e2, version: t2 };
      return this.notify("getInfo", i2), i2;
    } catch (n2) {
      return console.error("Using minimal getInfo", n2), { methods: ["sendPayment"], node: {}, supports: e2, version: t2 };
    }
  }
  async getBalance() {
    await this.checkEnabled();
    const e2 = await this.client.getBalance(), t2 = { balance: Math.floor(e2.balance / 1e3), currency: "sats" };
    return this.notify("getBalance", t2), t2;
  }
  async sendPayment(e2) {
    await this.checkEnabled();
    const t2 = { preimage: (await this.client.payInvoice({ invoice: e2 })).preimage };
    return this.notify("sendPayment", t2), t2;
  }
  async sendPaymentAsync(e2) {
    return await this.checkEnabled(), this.client.payInvoice({ invoice: e2 }), this.notify("sendPaymentAsync", {}), {};
  }
  async keysend(e2) {
    await this.checkEnabled();
    const t2 = { preimage: (await this.client.payKeysend(X2(e2))).preimage };
    return this.notify("keysend", t2), t2;
  }
  async signMessage(e2) {
    await this.checkEnabled();
    const t2 = await this.client.signMessage({ message: e2 }), n2 = { message: t2.message, signature: t2.signature };
    return this.notify("keysend", n2), n2;
  }
  async makeInvoice(e2) {
    var t2;
    await this.checkEnabled();
    const n2 = "object" == typeof e2 ? e2 : void 0, i2 = +(null != (t2 = null == n2 ? void 0 : n2.amount) ? t2 : e2);
    if (!i2) throw new Error("No amount specified");
    const s2 = { paymentRequest: (await this.client.makeInvoice({ amount: 1e3 * i2, description: null == n2 ? void 0 : n2.defaultMemo })).invoice };
    return this.notify("makeInvoice", s2), s2;
  }
  async lookupInvoice(e2) {
    await this.checkEnabled();
    const t2 = await this.client.lookupInvoice({ invoice: e2.paymentRequest, payment_hash: e2.paymentHash }), n2 = { preimage: t2.preimage, paymentRequest: t2.invoice, paid: !!t2.settled_at };
    return this.notify("lookupInvoice", n2), n2;
  }
  async listTransactions(e2) {
    await this.checkEnabled();
    const t2 = { transactions: (await this.client.listTransactions(e2)).transactions.map(Y2) };
    return this.notify("listTransactions", t2), t2;
  }
  async sendMultiPayment(e2) {
    await this.checkEnabled();
    const t2 = await this.client.multiPayInvoice({ invoices: e2.map((e3, t3) => ({ invoice: e3, id: t3.toString() })) }), n2 = { payments: t2.invoices.map((t3) => {
      const n3 = e2[parseInt(t3.dTag)];
      if (!n3) throw new Error("Could not find paymentRequest matching response d tag");
      return { paymentRequest: n3, preimage: t3.preimage };
    }), errors: [] };
    return this.notify("sendMultiPayment", n2), n2;
  }
  async multiKeysend(e2) {
    await this.checkEnabled();
    const t2 = await this.client.multiPayKeysend({ keysends: e2.map((e3, t3) => h2({}, X2(e3), { id: t3.toString() })) }), n2 = { keysends: t2.keysends.map((t3) => {
      const n3 = e2[parseInt(t3.dTag)];
      if (!n3) throw new Error("Could not find keysend matching response d tag");
      return { keysend: n3, preimage: t3.preimage };
    }), errors: [] };
    return this.notify("multiKeysend", n2), n2;
  }
  lnurl(e2) {
    throw new Error("Method not implemented.");
  }
  request(e2, t2) {
    throw new Error("Method not implemented.");
  }
  verifyMessage(e2, t2) {
    throw new Error("Method not implemented.");
  }
  async checkEnabled() {
    if (!this._enabled) throw new Error("please call enable() and await the promise before calling this function");
  }
};
function Y2(e2) {
  return h2({}, e2, { amount: Math.floor(e2.amount / 1e3), fees_paid: e2.fees_paid ? Math.floor(e2.fees_paid / 1e3) : 0 });
}
function X2(e2) {
  return { amount: 1e3 * +e2.amount, pubkey: e2.destination, tlv_records: e2.customRecords ? Object.entries(e2.customRecords).map((e3) => ({ type: parseInt(e3[0]), value: P2(new TextEncoder().encode(e3[1])) })) : [] };
}
var Q = { __proto__: null, NostrWebLNProvider: V2, NWC: V2, OauthWeblnProvider: class {
  constructor(e2) {
    this.client = void 0, this.auth = void 0, this.oauth = void 0, this.subscribers = void 0, this.isExecuting = void 0, this.auth = e2.auth, this.client = new I2(e2.auth), this.oauth = true, this.subscribers = {}, this.isExecuting = false;
  }
  on(e2, t2) {
    this.subscribers[e2] = t2;
  }
  notify(e2, t2) {
    const n2 = this.subscribers[e2];
    n2 && n2(t2);
  }
  async enable() {
    var e2;
    if (!this.isExecuting) {
      if (null != (e2 = this.auth.token) && e2.access_token) return { enabled: true };
      if ("undefined" == typeof window || void 0 === window.document) throw new Error("Missing access token");
      try {
        this.isExecuting = true, await this.openAuthorization();
      } finally {
        this.isExecuting = false;
      }
    }
  }
  async sendPayment(e2) {
    if (!this.isExecuting) try {
      this.isExecuting = true;
      const t2 = await this.client.sendPayment({ invoice: e2 });
      return this.notify("sendPayment", t2), { preimage: t2.payment_preimage };
    } catch (e3) {
      let t2 = "Unknown Error";
      throw e3 instanceof Error && (t2 = e3.message), new Error(t2);
    } finally {
      this.isExecuting = false;
    }
  }
  async keysend(e2) {
    if (!this.isExecuting) try {
      this.isExecuting = true;
      const t2 = await this.client.keysend(e2);
      return this.notify("keysend", t2), { preimage: t2.payment_preimage };
    } catch (e3) {
      let t2 = "Unknown Error";
      throw e3 instanceof Error && (t2 = e3.message), new Error(t2);
    } finally {
      this.isExecuting = false;
    }
  }
  async getInfo() {
    return { alias: "Alby" };
  }
  async makeInvoice(e2) {
    if (!this.isExecuting) try {
      this.isExecuting = true;
      const t2 = await this.client.createInvoice({ amount: parseInt(e2.amount.toString()), description: e2.defaultMemo });
      return this.notify("makeInvoice", t2), { paymentRequest: t2.payment_request };
    } catch (e3) {
      let t2 = "Unknown Error";
      throw e3 instanceof Error && (t2 = e3.message), new Error(t2);
    } finally {
      this.isExecuting = false;
    }
  }
  async openAuthorization() {
    var e2 = this;
    const t2 = window.outerHeight / 2 + window.screenY - 350, n2 = window.outerWidth / 2 + window.screenX - 300, i2 = await this.auth.generateAuthURL({ code_challenge_method: "S256" });
    return new Promise((s2, o2) => {
      const r2 = window.open(i2, `${document.title} - WebLN enable`, `height=700,width=600,top=${t2},left=${n2}`);
      let a2 = false;
      window.addEventListener("message", async function(t3) {
        const n3 = t3.data;
        if (n3 && "alby:oauth:success" === n3.type && t3.origin === `${document.location.protocol}//${document.location.host}` && !a2) {
          a2 = true, console.info("Processing OAuth code response");
          const t4 = n3.payload.code;
          try {
            await e2.auth.requestAccessToken(t4), e2.client = new I2(e2.auth), r2 && r2.close(), e2.notify("enable"), s2({ enabled: true });
          } catch (e3) {
            console.error(e3), o2({ enabled: false });
          }
        }
      });
    });
  }
} };
var Z2 = { __proto__: null, Nip47Error: M2, Nip47NetworkError: W2, Nip47WalletError: $2, Nip47TimeoutError: F2, Nip47PublishTimeoutError: L2, Nip47ReplyTimeoutError: K2, Nip47PublishError: j2, Nip47ResponseDecodingError: J2, Nip47ResponseValidationError: B2, Nip47UnexpectedResponseError: H2, Nip47UnsupportedEncryptionError: z2, NWCClient: D2, NWAClient: class {
  constructor(t2) {
    if (this.options = void 0, this.appSecretKey = void 0, this.relay = void 0, this.appSecretKey = t2.appSecretKey || O2(generateSecretKey()), this.options = h2({}, t2, { appPubkey: getPublicKey(C2(this.appSecretKey)) }), !this.options.relayUrl) throw new Error("Missing relay url");
    if (!this.options.requestMethods) throw new Error("Missing request methods");
    this.relay = new Relay(this.options.relayUrl), void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
  }
  get connectionUri() {
    return this.getConnectionUri();
  }
  getConnectionUri(e2 = "") {
    const t2 = new URLSearchParams(h2({ relay: this.options.relayUrl, request_methods: this.options.requestMethods.join(" ") }, this.options.name ? { name: this.options.name } : {}, this.options.icon ? { icon: this.options.icon } : {}, this.options.returnTo ? { return_to: this.options.returnTo } : {}, this.options.notificationTypes ? { notification_types: this.options.notificationTypes.join(" ") } : {}, this.options.maxAmount ? { max_amount: this.options.maxAmount.toString() } : {}, this.options.budgetRenewal ? { budget_renewal: this.options.budgetRenewal } : {}, this.options.expiresAt ? { expires_at: this.options.expiresAt.toString() } : {}, this.options.isolated ? { isolated: this.options.isolated.toString() } : {}, this.options.metadata ? { metadata: JSON.stringify(this.options.metadata) } : {}));
    return `nostr+walletauth${e2 ? `+${e2}` : ""}://${this.options.appPubkey}?${t2.toString().replace(/\+/g, "%20")}`;
  }
  static parseWalletAuthUrl(e2) {
    var t2, n2;
    if (!e2.startsWith("nostr+walletauth")) throw new Error("Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://");
    const i2 = e2.indexOf(":");
    (e2 = e2.substring(i2 + 1)).startsWith("//") && (e2 = e2.substring(2)), e2 = "http://" + e2;
    const s2 = new URL(e2), o2 = s2.host;
    if (64 !== (null == o2 ? void 0 : o2.length)) throw new Error("Incorrect app pubkey found in auth string");
    const r2 = s2.searchParams.get("relay");
    if (!r2) throw new Error("No relay URL found in auth string");
    const a2 = null == (t2 = s2.searchParams.get("request_methods")) ? void 0 : t2.split(" ");
    if (null == a2 || !a2.length) throw new Error("No request methods found in auth string");
    const c2 = null == (n2 = s2.searchParams.get("notification_types")) ? void 0 : n2.split(" "), l2 = s2.searchParams.get("max_amount"), u2 = s2.searchParams.get("expires_at"), h3 = s2.searchParams.get("metadata");
    return { name: s2.searchParams.get("name") || void 0, icon: s2.searchParams.get("icon") || void 0, returnTo: s2.searchParams.get("return_to") || void 0, relayUrl: r2, appPubkey: o2, requestMethods: a2, notificationTypes: c2, budgetRenewal: s2.searchParams.get("budget_renewal"), expiresAt: u2 ? parseInt(u2) : void 0, maxAmount: l2 ? parseInt(l2) : void 0, isolated: "true" === s2.searchParams.get("isolated"), metadata: h3 ? JSON.parse(h3) : void 0 };
  }
  async subscribe(e2) {
    var t2 = this;
    let n2, i2, s2 = true;
    return async function() {
      for (; s2; ) {
        try {
          await t2._checkConnected();
          const s3 = t2.relay.subscribe([{ kinds: [13194], "#p": [t2.options.appPubkey] }], {});
          console.info("subscribed to relay");
          const o2 = () => {
            s3.close(), t2.relay.close();
          };
          s3.onevent = async function(n3) {
            const i3 = new D2({ relayUrl: t2.options.relayUrl, secret: t2.appSecretKey, walletPubkey: n3.pubkey });
            try {
              const e3 = await i3.getInfo();
              i3.options.lud16 = e3.lud16, i3.lud16 = e3.lud16;
            } catch (e3) {
              console.error("failed to fetch get_info", e3);
            }
            e2.onSuccess(i3), o2();
          }, await new Promise((e3) => {
            n2 = () => {
              e3();
            }, i2 = () => {
              console.info("relay disconnected"), null == n2 || n2();
            }, t2.relay.onclose = i2;
          }), void 0 !== i2 && (t2.relay.onclose = null);
        } catch (e3) {
          console.error("error subscribing to info event", e3 || "unknown relay error");
        }
        s2 && await new Promise((e3) => setTimeout(e3, 1e3));
      }
    }(), { unsub: () => {
      s2 = false, null == n2 || n2();
    } };
  }
  async _checkConnected() {
    if (!this.appSecretKey) throw new Error("Missing secret key");
    if (!this.options.relayUrl) throw new Error("Missing relay url");
    try {
      this.relay.connected || await this.relay.connect();
    } catch (e2) {
      throw console.error("failed to connect to relay", this.options.relayUrl), new W2("Failed to connect to " + this.options.relayUrl, "OTHER");
    }
  }
}, NWCWalletServiceKeyPair: class {
  constructor(e2, t2) {
    if (this.walletSecret = void 0, this.walletPubkey = void 0, this.clientPubkey = void 0, this.walletSecret = e2, this.clientPubkey = t2, !this.walletSecret) throw new Error("Missing wallet secret key");
    if (!this.clientPubkey) throw new Error("Missing client pubkey");
    this.walletPubkey = getPublicKey(C2(this.walletSecret));
  }
}, NWCWalletService: class {
  constructor(t2) {
    this.relay = void 0, this.relayUrl = void 0, this.relayUrl = t2.relayUrl, this.relay = new Relay(this.relayUrl), void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
  }
  async publishWalletServiceInfoEvent(e2, t2, n2) {
    try {
      await this._checkConnected();
      const i2 = { kind: 13194, created_at: Math.floor(Date.now() / 1e3), tags: [["encryption", "nip04 nip44_v2"], ["notifications", n2.join(" ")]], content: t2.join(" ") }, s2 = await this.signEvent(i2, e2);
      await this.relay.publish(s2);
    } catch (e3) {
      throw console.error("failed to publish wallet service info event", e3), e3;
    }
  }
  async subscribe(e2, t2) {
    var n2 = this;
    let i2, s2, o2, r2 = true;
    return async function() {
      for (; r2; ) {
        try {
          console.info("checking connection to relay"), await n2._checkConnected(), console.info("subscribing to relay"), o2 = n2.relay.subscribe([{ kinds: [23194], authors: [e2.clientPubkey], "#p": [e2.walletPubkey] }], {}), console.info("subscribed to relay"), o2.onevent = async function(i3) {
            try {
              var s3;
              const o3 = (null == (s3 = i3.tags.find((e3) => "encryption" === e3[0])) ? void 0 : s3[1]) || "nip04", r3 = await n2.decrypt(e2, i3.content, o3), a2 = JSON.parse(r3);
              let c2;
              switch (a2.method) {
                case "get_info":
                  c2 = null == t2.getInfo ? void 0 : t2.getInfo();
                  break;
                case "make_invoice":
                  c2 = null == t2.makeInvoice ? void 0 : t2.makeInvoice(a2.params);
                  break;
                case "pay_invoice":
                  c2 = null == t2.payInvoice ? void 0 : t2.payInvoice(a2.params);
                  break;
                case "pay_keysend":
                  c2 = null == t2.payKeysend ? void 0 : t2.payKeysend(a2.params);
                  break;
                case "get_balance":
                  c2 = null == t2.getBalance ? void 0 : t2.getBalance();
                  break;
                case "lookup_invoice":
                  c2 = null == t2.lookupInvoice ? void 0 : t2.lookupInvoice(a2.params);
                  break;
                case "list_transactions":
                  c2 = null == t2.listTransactions ? void 0 : t2.listTransactions(a2.params);
                  break;
                case "sign_message":
                  c2 = null == t2.signMessage ? void 0 : t2.signMessage(a2.params);
              }
              let l2 = await c2;
              l2 || (console.warn("received unsupported method", a2.method), l2 = { error: { code: "NOT_IMPLEMENTED", message: "This method is not supported by the wallet service" }, result: void 0 });
              const u2 = { kind: 23195, created_at: Math.floor(Date.now() / 1e3), tags: [["e", i3.id]], content: await n2.encrypt(e2, JSON.stringify(h2({ result_type: a2.method }, l2)), o3) }, d3 = await n2.signEvent(u2, e2.walletSecret);
              await n2.relay.publish(d3);
            } catch (e3) {
              return void console.error("Failed to parse decrypted event content", e3);
            }
          }, await new Promise((e3) => {
            i2 = () => {
              e3();
            }, s2 = () => {
              console.error("relay disconnected"), null == i2 || i2();
            }, n2.relay.onclose = s2;
          }), void 0 !== s2 && (n2.relay.onclose = null);
        } catch (e3) {
          console.error("error subscribing to requests", e3 || "unknown relay error");
        }
        r2 && await new Promise((e3) => setTimeout(e3, 1e3));
      }
    }(), () => {
      var e3;
      r2 = false, null == i2 || i2(), null == (e3 = o2) || e3.close();
    };
  }
  get connected() {
    return this.relay.connected;
  }
  signEvent(e2, t2) {
    return Promise.resolve(finalizeEvent(e2, C2(t2)));
  }
  close() {
    return this.relay.close();
  }
  async encrypt(e2, t2, n2) {
    let i2;
    if ("nip04" === n2) i2 = await nip04_exports.encrypt(e2.walletSecret, e2.clientPubkey, t2);
    else {
      const n3 = nip44_exports.getConversationKey(C2(e2.walletSecret), e2.clientPubkey);
      i2 = nip44_exports.encrypt(t2, n3);
    }
    return i2;
  }
  async decrypt(e2, t2, n2) {
    let i2;
    if ("nip04" === n2) i2 = await nip04_exports.decrypt(e2.walletSecret, e2.clientPubkey, t2);
    else {
      const n3 = nip44_exports.getConversationKey(C2(e2.walletSecret), e2.clientPubkey);
      i2 = nip44_exports.decrypt(t2, n3);
    }
    return i2;
  }
  async _checkConnected() {
    if (!this.relayUrl) throw new Error("Missing relay url");
    try {
      this.relay.connected || await this.relay.connect();
    } catch (e2) {
      throw console.error("failed to connect to relay", this.relayUrl), new W2("Failed to connect to " + this.relayUrl, "OTHER");
    }
  }
} };
var ee2 = class {
  constructor(e2, t2) {
    this.transaction = void 0, this.invoice = void 0, this._nwcClient = void 0, this._unsubscribeFunc = void 0, this._timeoutFunc = void 0, this._timeoutId = void 0, this.transaction = t2, this.invoice = new j({ pr: t2.invoice }), this._nwcClient = e2;
  }
  onPaid(e2) {
    var t2 = this;
    return async function() {
      let n2;
      try {
        var i2;
        n2 = null == (i2 = (await t2._nwcClient.getInfo()).notifications) ? void 0 : i2.includes("payment_received");
      } catch (e3) {
        console.error("failed to fetch info, falling back to polling");
      }
      const s2 = (n3) => {
        null == t2._unsubscribeFunc || t2._unsubscribeFunc(), e2(n3);
      }, o2 = (e3) => () => {
        t2._timeoutFunc = void 0, clearTimeout(t2._timeoutId), e3();
      };
      if (n2) {
        const e3 = (e4) => {
          e4.notification.payment_hash === t2.transaction.payment_hash && s2(e4.notification);
        };
        t2._unsubscribeFunc = o2(await t2._nwcClient.subscribeNotifications(e3, ["payment_received"]));
      } else console.warn("current connection does not support notifications, falling back to polling"), t2._unsubscribeFunc = o2(t2._onPaidPollingFallback(s2));
    }(), this;
  }
  onTimeout(e2, t2) {
    return this._timeoutFunc = () => {
      var e3;
      null == (e3 = this._unsubscribeFunc) || e3.call(this), t2();
    }, this._timeoutId = setTimeout(() => {
      var e3;
      null == (e3 = this._timeoutFunc) || e3.call(this);
    }, 1e3 * e2), this;
  }
  unsubscribe() {
    var e2;
    null == (e2 = this._unsubscribeFunc) || e2.call(this);
  }
  _onPaidPollingFallback(e2) {
    var t2 = this;
    let n2 = true;
    return async function() {
      for (; n2; ) {
        const i2 = await t2._nwcClient.lookupInvoice({ payment_hash: t2.transaction.payment_hash });
        if (i2.settled_at && i2.preimage) {
          e2(i2), n2 = false;
          break;
        }
        await new Promise((e3) => setTimeout(e3, 3e3));
      }
    }(), () => {
      n2 = false;
    };
  }
};
var te = (e2) => ({ satoshi: e2 });
async function ne2(e2) {
  if ("number" == typeof e2) return { satoshi: e2, millisat: 1e3 * e2 };
  const t2 = await Promise.resolve(e2.satoshi);
  return { satoshi: t2, millisat: 1e3 * t2 };
}
var ie2 = class {
  constructor(e2) {
    this.nwcClient = void 0, this.nwcClient = "string" == typeof e2 ? new D2({ nostrWalletConnectUrl: e2 }) : e2 instanceof D2 ? e2 : new D2(e2);
  }
  async pay(e2, t2, n2) {
    let i2 = e2;
    const s2 = t2 ? await ne2(t2) : void 0;
    if (i2.indexOf("@") > -1) {
      var o2, r2;
      if (!s2) throw new Error("Amount must be provided when paying to a lightning address");
      const t3 = new Y(e2);
      await t3.fetch(), i2 = (await t3.requestInvoice({ satoshi: s2.satoshi, comment: null == n2 || null == (o2 = n2.metadata) ? void 0 : o2.comment, payerdata: null == n2 || null == (r2 = n2.metadata) ? void 0 : r2.payer_data })).paymentRequest;
    }
    const a2 = await this.nwcClient.payInvoice(h2({}, n2 || {}, { invoice: i2, amount: null == s2 ? void 0 : s2.millisat }));
    return h2({}, a2, { invoice: new j({ pr: i2 }) });
  }
  async requestPayment(e2, t2) {
    const n2 = await ne2(e2), i2 = await this.nwcClient.makeInvoice(h2({}, t2 || {}, { amount: n2.millisat }));
    return new ee2(this.nwcClient, i2);
  }
  close() {
    this.nwcClient.close();
  }
};
var se = class {
  constructor(e2, t2) {
    this.satoshi = void 0, this.satoshi = le.getSatoshiValue({ amount: e2, currency: t2 });
  }
};
var oe = (e2) => new se(e2, "USD");
var re = (e2) => new se(e2, "EUR");
var ae2 = (e2) => new se(e2, "JPY");
var ce2 = (e2) => new se(e2, "GBP");
var le2 = (e2) => new se(e2, "CHF");
export {
  le2 as CHF,
  re as EUR,
  se as FiatAmount,
  ce2 as GBP,
  ae2 as JPY,
  ie2 as LN,
  ie2 as LNClient,
  ee2 as ReceiveInvoice,
  te as SATS,
  oe as USD,
  Z2 as nwc,
  A2 as oauth,
  ne2 as resolveAmount,
  Q as webln
};
//# sourceMappingURL=@getalby_sdk.js.map
