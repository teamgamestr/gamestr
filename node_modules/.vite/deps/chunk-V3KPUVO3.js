import {
  N64,
  NIP98,
  NSchema
} from "./chunk-7DLL7TTG.js";
import {
  v3_exports
} from "./chunk-WVEDXYV7.js";
import {
  finalizeEvent,
  getFilterLimit,
  getPublicKey,
  matchFilters,
  nip04_exports,
  nip44_exports,
  verifyEvent
} from "./chunk-RHRR5RQ3.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/@nostrify/nostrify/dist/BunkerURI.js
var BunkerURI = class _BunkerURI {
  constructor(uri) {
    /** Remote signer pubkey. */
    __publicField(this, "pubkey");
    /** Relay URLs on which the client is listening for responses from the remote-signer. */
    __publicField(this, "relays");
    /** A short random string that the remote-signer should return as the `result` field of its response. */
    __publicField(this, "secret");
    const url = new URL(uri);
    const params = new URLSearchParams(url.search);
    const pubkey = url.hostname || url.pathname.slice(2);
    const relays = params.getAll("relay");
    const secret = params.get("secret") ?? void 0;
    if (!pubkey) {
      throw new Error("Invalid bunker URI");
    }
    this.pubkey = pubkey;
    this.relays = relays;
    this.secret = secret;
  }
  /** Convert into a `bunker://` URI string. */
  get href() {
    return this.toString();
  }
  /** Convert into a `bunker://` URI string. */
  toString() {
    return _BunkerURI.toString(this);
  }
  /** Convert a bunker data object into a `BunkerURI` instance. */
  static fromJSON(data) {
    const uri = _BunkerURI.toString(data);
    return new _BunkerURI(uri);
  }
  /** Convert a bunker data object into a bunker URI string. */
  static toString(data) {
    const search = new URLSearchParams();
    for (const relay of data.relays) {
      search.append("relay", relay);
    }
    if (data.secret) {
      search.set("secret", data.secret);
    }
    return `bunker://${data.pubkey}?${search.toString()}`;
  }
};

// node_modules/@nostrify/nostrify/dist/NBrowserSigner.js
var NBrowserSigner = class {
  get nostr() {
    const nostr = globalThis.nostr;
    if (!nostr) {
      throw new Error("Browser extension not available");
    }
    return nostr;
  }
  async getPublicKey() {
    const pubkey = await this.nostr.getPublicKey();
    if (typeof pubkey !== "string") {
      throw new Error(`Nostr public key retrieval failed: expected string, got ${JSON.stringify(pubkey)}`);
    }
    return pubkey;
  }
  async signEvent(event) {
    const signed = await this.nostr.signEvent(event);
    if (typeof signed !== "object" || !signed.id || !signed.pubkey || !signed.sig) {
      throw new Error(
        `Nostr event signing failed: expected object with id, pubkey, and sig, got ${JSON.stringify(signed)}`
      );
    }
    return signed;
  }
  async getRelays() {
    if (!this.nostr.getRelays) {
      return {};
    }
    const relays = await this.nostr.getRelays();
    if (typeof relays !== "object" || relays === null) {
      throw new Error(`Nostr getRelays failed: expected object, got ${JSON.stringify(relays)}`);
    }
    return this.nostr.getRelays();
  }
  get nip04() {
    const nostr = this.nostr;
    if (!nostr.nip04) {
      return void 0;
    }
    return {
      encrypt: async (pubkey, plaintext) => {
        const encrypted = await nostr.nip04.encrypt(pubkey, plaintext);
        if (typeof encrypted !== "string") {
          throw new Error(`NIP-04 encryption failed: expected string result, got ${JSON.stringify(encrypted)}`);
        }
        return encrypted;
      },
      decrypt: async (pubkey, ciphertext) => {
        const decrypted = await nostr.nip04.decrypt(pubkey, ciphertext);
        if (typeof decrypted !== "string") {
          throw new Error(`NIP-04 decryption failed: expected string result, got ${JSON.stringify(decrypted)}`);
        }
        return decrypted;
      }
    };
  }
  get nip44() {
    const nostr = this.nostr;
    if (!nostr.nip44) {
      return void 0;
    }
    return {
      encrypt: async (pubkey, plaintext) => {
        const encrypted = await nostr.nip44.encrypt(pubkey, plaintext);
        if (typeof encrypted !== "string") {
          throw new Error(`NIP-44 encryption failed: expected string result, got ${JSON.stringify(encrypted)}`);
        }
        return encrypted;
      },
      decrypt: async (pubkey, ciphertext) => {
        const decrypted = await nostr.nip44.decrypt(pubkey, ciphertext);
        if (typeof decrypted !== "string") {
          throw new Error(`NIP-44 decryption failed: expected string result, got ${JSON.stringify(decrypted)}`);
        }
        return decrypted;
      }
    };
  }
};

// node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a5, _b4;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      (_b4 = (_a5 = this.signal).onabort) == null ? void 0 : _b4.call(_a5, reason);
    }
  };
  let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _a2, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _LRUCache_instances);
    // options that cannot be changed without disaster
    __privateAdd(this, _max);
    __privateAdd(this, _maxSize);
    __privateAdd(this, _dispose);
    __privateAdd(this, _disposeAfter);
    __privateAdd(this, _fetchMethod);
    __privateAdd(this, _memoMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size);
    __privateAdd(this, _calculatedSize);
    __privateAdd(this, _keyMap);
    __privateAdd(this, _keyList);
    __privateAdd(this, _valList);
    __privateAdd(this, _next);
    __privateAdd(this, _prev);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _free);
    __privateAdd(this, _disposed);
    __privateAdd(this, _sizes);
    __privateAdd(this, _starts);
    __privateAdd(this, _ttls);
    __privateAdd(this, _hasDispose);
    __privateAdd(this, _hasFetchMethod);
    __privateAdd(this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    __publicField(this, _a2, "LRUCache");
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    __privateSet(this, _max, max);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    __privateSet(this, _memoMethod, memoMethod);
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max).fill(void 0));
    __privateSet(this, _valList, new Array(max).fill(void 0));
    __privateSet(this, _next, new UintArray(max));
    __privateSet(this, _prev, new UintArray(max));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: __privateGet(c, _starts),
      ttls: __privateGet(c, _ttls),
      sizes: __privateGet(c, _sizes),
      keyMap: __privateGet(c, _keyMap),
      keyList: __privateGet(c, _keyList),
      valList: __privateGet(c, _valList),
      next: __privateGet(c, _next),
      prev: __privateGet(c, _prev),
      get head() {
        return __privateGet(c, _head);
      },
      get tail() {
        return __privateGet(c, _tail);
      },
      free: __privateGet(c, _free),
      // methods
      isBackgroundFetch: (p) => {
        var _a5;
        return __privateMethod(_a5 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a5, p);
      },
      backgroundFetch: (k, index, options, context) => {
        var _a5;
        return __privateMethod(_a5 = c, _LRUCache_instances, backgroundFetch_fn).call(_a5, k, index, options, context);
      },
      moveToTail: (index) => {
        var _a5;
        return __privateMethod(_a5 = c, _LRUCache_instances, moveToTail_fn).call(_a5, index);
      },
      indexes: (options) => {
        var _a5;
        return __privateMethod(_a5 = c, _LRUCache_instances, indexes_fn).call(_a5, options);
      },
      rindexes: (options) => {
        var _a5;
        return __privateMethod(_a5 = c, _LRUCache_instances, rindexes_fn).call(_a5, options);
      },
      isStale: (index) => {
        var _a5;
        return __privateGet(_a5 = c, _isStale).call(_a5, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  get memoMethod() {
    return __privateGet(this, _memoMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const k = __privateGet(this, _keyList)[i];
      if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k = __privateGet(this, _keyList)[i];
      if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield __privateGet(this, _valList)[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield __privateGet(this, _valList)[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b = Symbol.iterator, _a2 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, __privateGet(this, _keyList)[i], this)) {
        return this.get(__privateGet(this, _keyList)[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i)) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = __privateGet(this, _keyMap).get(key);
    if (i === void 0)
      return void 0;
    const v = __privateGet(this, _valList)[i];
    const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      const ttl = __privateGet(this, _ttls)[i];
      const start = __privateGet(this, _starts)[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (__privateGet(this, _sizes)) {
      entry.size = __privateGet(this, _sizes)[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i];
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i];
        const age = perf.now() - __privateGet(this, _starts)[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    var _a5, _b4, _c, _d, _e;
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "set");
      return this;
    }
    let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
    if (index === void 0) {
      index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index] = k;
      __privateGet(this, _valList)[index] = v;
      __privateGet(this, _keyMap).set(k, index);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index;
      __privateGet(this, _prev)[index] = __privateGet(this, _tail);
      __privateSet(this, _tail, index);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
      const oldVal = __privateGet(this, _valList)[index];
      if (v !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, s, k, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b4 = __privateGet(this, _disposed)) == null ? void 0 : _b4.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index);
        __privateGet(this, _addItemSize).call(this, index, size, status);
        __privateGet(this, _valList)[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a5;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a5 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a5.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = __privateGet(this, _keyMap).get(k);
    if (index !== void 0) {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = __privateGet(this, _keyMap).get(k);
    if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
      return;
    }
    const v = __privateGet(this, _valList)[index];
    return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = __privateGet(this, _keyMap).get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
      return p.__returned = p;
    } else {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = __privateGet(this, _isStale).call(this, index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        return v;
      }
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = __privateGet(this, _memoMethod);
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = __privateGet(this, _keyMap).get(k);
    if (index !== void 0) {
      const value = __privateGet(this, _valList)[index];
      const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
      if (__privateGet(this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_memoMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_LRUCache_instances = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index)) {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
        }
      }, ttl + 1);
      if (t.unref) {
        t.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start)
        return;
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n;
      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t.unref) {
        t.unref();
      }
    }
    return n;
  };
  this.getRemainingTTL = (key) => {
    const index = __privateGet(this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    const ttl = ttls[index];
    const start = starts[index];
    if (!ttl || !start) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index) => {
    const s = starts[index];
    const t = ttls[index];
    return !!t && !!s && (cachedNow || getNow()) - s > t;
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
    sizes[index] = 0;
  });
  __privateSet(this, _requireSize, (k, v, size, sizeCalculation) => {
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v, k);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index, size, status) => {
    sizes[index] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === __privateGet(this, _head)) {
        break;
      } else {
        i = __privateGet(this, _prev)[i];
      }
    }
  }
};
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === __privateGet(this, _tail)) {
        break;
      } else {
        i = __privateGet(this, _next)[i];
      }
    }
  }
};
isValidIndex_fn = function(index) {
  return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
};
evict_fn = function(free) {
  var _a5, _b4;
  const head = __privateGet(this, _head);
  const k = __privateGet(this, _keyList)[head];
  const v = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    v.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v, k, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b4 = __privateGet(this, _disposed)) == null ? void 0 : _b4.push([v, k, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k);
  __privateWrapper(this, _size)._--;
  return head;
};
backgroundFetch_fn = function(k, index, options, context) {
  const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
  if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    return v;
  }
  const ac = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v2, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p;
    if (__privateGet(this, _valList)[index] === p) {
      if (v2 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k, v2, fetchOpts.options);
      }
    }
    return v2;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p;
    if (__privateGet(this, _valList)[index] === p) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a5;
    const fmp = (_a5 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a5.call(this, k, v, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v2) => cb(v2, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p, {
    __abortController: ac,
    __staleWhileFetching: v,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k, bf, { ...fetchOpts.options, status: void 0 });
    index = __privateGet(this, _keyMap).get(k);
  } else {
    __privateGet(this, _valList)[index] = bf;
  }
  return bf;
};
isBackgroundFetch_fn = function(p) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b = p;
  return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
};
connect_fn = function(p, n) {
  __privateGet(this, _prev)[n] = p;
  __privateGet(this, _next)[p] = n;
};
moveToTail_fn = function(index) {
  if (index !== __privateGet(this, _tail)) {
    if (index === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index]);
    } else {
      __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
    }
    __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index);
    __privateSet(this, _tail, index);
  }
};
delete_fn = function(k, reason) {
  var _a5, _b4, _c, _d;
  let deleted = false;
  if (__privateGet(this, _size) !== 0) {
    const index = __privateGet(this, _keyMap).get(k);
    if (index !== void 0) {
      deleted = true;
      if (__privateGet(this, _size) === 1) {
        __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
      } else {
        __privateGet(this, _removeItemSize).call(this, index);
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
          if (__privateGet(this, _hasDispose)) {
            (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v, k, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b4 = __privateGet(this, _disposed)) == null ? void 0 : _b4.push([v, k, reason]);
          }
        }
        __privateGet(this, _keyMap).delete(k);
        __privateGet(this, _keyList)[index] = void 0;
        __privateGet(this, _valList)[index] = void 0;
        if (index === __privateGet(this, _tail)) {
          __privateSet(this, _tail, __privateGet(this, _prev)[index]);
        } else if (index === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index]);
        } else {
          const pi = __privateGet(this, _prev)[index];
          __privateGet(this, _next)[pi] = __privateGet(this, _next)[index];
          const ni = __privateGet(this, _next)[index];
          __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
        }
        __privateWrapper(this, _size)._--;
        __privateGet(this, _free).push(index);
      }
    }
  }
  if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
    const dt = __privateGet(this, _disposed);
    let task;
    while (task = dt == null ? void 0 : dt.shift()) {
      (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
    }
  }
  return deleted;
};
clear_fn = function(reason) {
  var _a5, _b4, _c;
  for (const index of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
    const v = __privateGet(this, _valList)[index];
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      v.__abortController.abort(new Error("deleted"));
    } else {
      const k = __privateGet(this, _keyList)[index];
      if (__privateGet(this, _hasDispose)) {
        (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v, k, reason);
      }
      if (__privateGet(this, _hasDisposeAfter)) {
        (_b4 = __privateGet(this, _disposed)) == null ? void 0 : _b4.push([v, k, reason]);
      }
    }
  }
  __privateGet(this, _keyMap).clear();
  __privateGet(this, _valList).fill(void 0);
  __privateGet(this, _keyList).fill(void 0);
  if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
    __privateGet(this, _ttls).fill(0);
    __privateGet(this, _starts).fill(0);
  }
  if (__privateGet(this, _sizes)) {
    __privateGet(this, _sizes).fill(0);
  }
  __privateSet(this, _head, 0);
  __privateSet(this, _tail, 0);
  __privateGet(this, _free).length = 0;
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _size, 0);
  if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
    const dt = __privateGet(this, _disposed);
    let task;
    while (task = dt == null ? void 0 : dt.shift()) {
      (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
    }
  }
};
var LRUCache = _LRUCache;

// node_modules/@nostrify/nostrify/dist/NSet.js
var _a3, _b2, _NSet_instances, processDeletions_fn;
var _NSet = class _NSet {
  constructor(map) {
    __privateAdd(this, _NSet_instances);
    __publicField(this, "cache");
    __publicField(this, _a3, "NSet");
    this.cache = map ?? /* @__PURE__ */ new Map();
  }
  get size() {
    return this.cache.size;
  }
  add(event) {
    __privateMethod(this, _NSet_instances, processDeletions_fn).call(this, event);
    for (const e of this) {
      if (_NSet.deletes(e, event) || _NSet.replaces(e, event)) {
        return this;
      } else if (_NSet.replaces(event, e)) {
        this.delete(e);
      }
    }
    this.cache.set(event.id, event);
    return this;
  }
  clear() {
    this.cache.clear();
  }
  delete(event) {
    return this.cache.delete(event.id);
  }
  forEach(callbackfn, thisArg) {
    return this.cache.forEach(
      (event, _id) => callbackfn(event, event, this),
      thisArg
    );
  }
  has(event) {
    return this.cache.has(event.id);
  }
  *entries() {
    for (const event of this.values()) {
      yield [event, event];
    }
  }
  keys() {
    return this.values();
  }
  *values() {
    for (const event of _NSet.sortEvents([...this.cache.values()])) {
      yield event;
    }
  }
  [(_b2 = Symbol.iterator, _a3 = Symbol.toStringTag, _b2)]() {
    return this.values();
  }
  /** Event kind is **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */
  static isReplaceable(kind) {
    return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
  }
  /** Event kind is **parameterized replaceable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */
  static isAddressable(kind) {
    return 3e4 <= kind && kind < 4e4;
  }
  /**
   * Returns true if `event` replaces `target`.
   *
   * Both events must be replaceable, belong to the same kind and pubkey (and `d` tag, for parameterized events), and the `event` must be newer than the `target`.
   */
  static replaces(event, target) {
    var _a5, _b4;
    const { kind, pubkey } = event;
    if (_NSet.isReplaceable(kind)) {
      return kind === target.kind && pubkey === target.pubkey && _NSet.sortEvents([event, target])[0] === event;
    }
    if (_NSet.isAddressable(kind)) {
      const d1 = ((_a5 = event.tags.find(([name]) => name === "d")) == null ? void 0 : _a5[1]) || "";
      const d2 = ((_b4 = target.tags.find(([name]) => name === "d")) == null ? void 0 : _b4[1]) || "";
      return kind === target.kind && pubkey === target.pubkey && _NSet.sortEvents([event, target])[0] === event && d1 === d2;
    }
    return false;
  }
  /**
   * Returns true if the `event` deletes`target`.
   *
   * `event` must be a kind `5` event, and both events must share the same `pubkey`.
   */
  static deletes(event, target) {
    const { kind, pubkey, tags } = event;
    if (kind === 5 && pubkey === target.pubkey) {
      for (const [name, value] of tags) {
        if (name === "e" && value === target.id) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Sort events in reverse-chronological order by the `created_at` timestamp,
   * and then by the event `id` (lexicographically) in case of ties.
   * This mutates the array.
   */
  static sortEvents(events) {
    return events.sort((a, b) => {
      if (a.created_at !== b.created_at) {
        return b.created_at - a.created_at;
      }
      return a.id.localeCompare(b.id);
    });
  }
  union(_other) {
    throw new Error("Method not implemented.");
  }
  intersection(_other) {
    throw new Error("Method not implemented.");
  }
  difference(_other) {
    throw new Error("Method not implemented.");
  }
  symmetricDifference(_other) {
    throw new Error("Method not implemented.");
  }
  isSubsetOf(_other) {
    throw new Error("Method not implemented.");
  }
  isSupersetOf(_other) {
    throw new Error("Method not implemented.");
  }
  isDisjointFrom(_other) {
    throw new Error("Method not implemented.");
  }
};
_NSet_instances = new WeakSet();
processDeletions_fn = function(event) {
  if (event.kind === 5) {
    for (const tag of event.tags) {
      if (tag[0] === "e") {
        const e = this.cache.get(tag[1]);
        if (e && e.pubkey === event.pubkey) {
          this.delete(e);
        }
      }
    }
  }
};
var NSet = _NSet;

// node_modules/@nostrify/nostrify/dist/NCache.js
var _a4, _b3;
var NCache = class extends (_b3 = NSet, _a4 = Symbol.toStringTag, _b3) {
  constructor(...args) {
    super(new LRUCache(...args));
    __publicField(this, _a4, "NCache");
  }
  async event(event) {
    this.add(event);
  }
  async query(filters) {
    const events = [];
    for (const event of this) {
      if (matchFilters(filters, event)) {
        this.cache.get(event.id);
        events.push(event);
      }
    }
    return events;
  }
  async remove(filters) {
    for (const event of this) {
      if (matchFilters(filters, event)) {
        this.delete(event);
      }
    }
  }
  async count(filters) {
    const events = await this.query(filters);
    return {
      count: events.length,
      approximate: false
    };
  }
};

// node_modules/@nostrify/nostrify/dist/NConnectSigner.js
var NConnectSigner = class {
  constructor({ relay, pubkey, signer, timeout, encryption = "nip44" }) {
    __publicField(this, "relay");
    __publicField(this, "pubkey");
    __publicField(this, "signer");
    __publicField(this, "timeout");
    __publicField(this, "encryption");
    __publicField(this, "nip04", {
      encrypt: async (pubkey, plaintext) => {
        return this.cmd("nip04_encrypt", [pubkey, plaintext]);
      },
      decrypt: async (pubkey, ciphertext) => {
        return this.cmd("nip04_decrypt", [pubkey, ciphertext]);
      }
    });
    __publicField(this, "nip44", {
      encrypt: async (pubkey, plaintext) => {
        return this.cmd("nip44_encrypt", [pubkey, plaintext]);
      },
      decrypt: async (pubkey, ciphertext) => {
        return this.cmd("nip44_decrypt", [pubkey, ciphertext]);
      }
    });
    this.relay = relay;
    this.pubkey = pubkey;
    this.signer = signer;
    this.timeout = timeout;
    this.encryption = encryption;
  }
  async getPublicKey() {
    return this.cmd("get_public_key", []);
  }
  async signEvent(event) {
    const result = await this.cmd("sign_event", [JSON.stringify(event)]);
    return NSchema.json().pipe(NSchema.event()).parse(result);
  }
  async getRelays() {
    const result = await this.cmd("get_relays", []);
    return NSchema.json().pipe(
      v3_exports.record(
        v3_exports.string(),
        v3_exports.object({ read: v3_exports.boolean(), write: v3_exports.boolean() })
      )
    ).parse(result);
  }
  /** Send a `connect` command to the relay. It should respond with `ack`. */
  async connect(secret) {
    const params = [this.pubkey];
    if (secret) {
      params.push(secret);
    }
    return this.cmd("connect", params);
  }
  /** Send a `ping` command to the signer. It should respond with `pong`. */
  async ping() {
    return this.cmd("ping", []);
  }
  /** High-level RPC method. Returns the string result, or throws on error. */
  async cmd(method, params) {
    const signal = typeof this.timeout === "number" ? AbortSignal.timeout(this.timeout) : void 0;
    const { result, error } = await this.send(
      { id: crypto.randomUUID(), method, params },
      { signal }
    );
    if (error) {
      throw new Error(error);
    }
    return result;
  }
  /** Low-level send method. Deals directly with connect request/response. */
  async send(request, opts = {}) {
    const { signal } = opts;
    const event = await this.signer.signEvent({
      kind: 24133,
      content: await this.encrypt(this.pubkey, JSON.stringify(request)),
      created_at: Math.floor(Date.now() / 1e3),
      tags: [["p", this.pubkey]]
    });
    const local = await this.signer.getPublicKey();
    const req = this.relay.req(
      [{ kinds: [24133], authors: [this.pubkey], "#p": [local] }],
      { signal }
    );
    const promise = new Promise((resolve, reject) => {
      (async () => {
        try {
          for await (const msg of req) {
            if (msg[0] === "CLOSED") throw new Error("Subscription closed");
            if (msg[0] === "EVENT") {
              const event2 = msg[2];
              const decrypted = await this.decrypt(this.pubkey, event2.content);
              const response = NSchema.json().pipe(NSchema.connectResponse()).parse(
                decrypted
              );
              if (response.id === request.id) {
                resolve(response);
                return;
              }
            }
          }
        } catch (error) {
          reject(error);
        }
      })();
    });
    await this.relay.event(event, { signal });
    return promise;
  }
  /** Local encrypt depending on settings. */
  async encrypt(pubkey, plaintext) {
    switch (this.encryption) {
      case "nip04":
        return this.signer.nip04.encrypt(pubkey, plaintext);
      case "nip44":
        return this.signer.nip44.encrypt(pubkey, plaintext);
    }
  }
  /** Local decrypt depending on settings. */
  async decrypt(pubkey, ciphertext) {
    switch (this.encryption) {
      case "nip04":
        return this.signer.nip04.decrypt(pubkey, ciphertext);
      case "nip44":
        return this.signer.nip44.decrypt(pubkey, ciphertext);
    }
  }
};

// node_modules/@nostrify/nostrify/dist/NIP05.js
var NIP05 = class _NIP05 {
  /** NIP-05 value regex. */
  static regex() {
    return /^(?:([\w.+-]+)@)?([\w.-]+)$/;
  }
  /** Nostr pubkey with relays object. */
  static profilePointerSchema() {
    return v3_exports.object({
      pubkey: NSchema.id(),
      relays: NSchema.relayUrl().array().optional()
    });
  }
  /** Resolve NIP-05 name to a profile pointer. */
  static async lookup(nip05, opts) {
    var _a5;
    const { fetch = globalThis.fetch.bind(globalThis), signal } = opts ?? {};
    const match = nip05.match(_NIP05.regex());
    if (!match) throw new Error(`NIP-05: invalid name ${nip05}`);
    const [_, name = "_", domain] = match;
    const url = new URL("/.well-known/nostr.json", `https://${domain}/`);
    url.searchParams.set("name", name);
    const response = await fetch(url, { signal });
    const json = await response.json();
    try {
      const pubkey = json.names[name];
      const relays = (_a5 = json.relays) == null ? void 0 : _a5[pubkey];
      return _NIP05.profilePointerSchema().parse({ pubkey, relays });
    } catch {
      throw new Error(`NIP-05: no match for ${nip05}`);
    }
  }
};

// node_modules/@nostrify/nostrify/dist/NIP50.js
var NIP50 = class {
  static parseInput(input) {
    const regex = /(\B-\w+:[^\s"]+)|(\b\w+:[^\s"]+)|(".*?")|(\S+)/g;
    const tokens = [];
    let match;
    while ((match = regex.exec(input)) !== null) {
      if (match[1] || match[2]) {
        const [key, ...values] = (match[1] || match[2]).split(":");
        tokens.push({ key, value: values.join(":") });
      } else if (match[3]) {
        tokens.push(match[3].replace(/"/g, ""));
      } else if (match[4]) {
        tokens.push(match[4]);
      }
    }
    return tokens;
  }
};

// node_modules/@nostrify/nostrify/dist/NIP98Client.js
var NIP98Client = class {
  constructor(opts) {
    __publicField(this, "signer");
    __publicField(this, "customFetch");
    this.signer = opts.signer;
    this.customFetch = opts.fetch ?? globalThis.fetch.bind(globalThis);
  }
  /** Performs a fetch request with NIP98 authentication */
  async fetch(input, init) {
    const request = new Request(input, init);
    const template = await NIP98.template(request);
    const event = await this.signer.signEvent(template);
    const token = N64.encodeEvent(event);
    request.headers.set("Authorization", `Nostr ${token}`);
    return this.customFetch(request);
  }
};

// node_modules/@nostrify/nostrify/dist/NKinds.js
var NKinds = class _NKinds {
  /** Events are **regular**, which means they're all expected to be stored by relays. */
  static regular(kind) {
    return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);
  }
  /** Events are **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */
  static replaceable(kind) {
    return 1e4 <= kind && kind < 2e4 || [0, 3].includes(kind);
  }
  /** Events are **ephemeral**, which means they are not expected to be stored by relays. */
  static ephemeral(kind) {
    return 2e4 <= kind && kind < 3e4;
  }
  /** Events are **addressable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */
  static addressable(kind) {
    return 3e4 <= kind && kind < 4e4;
  }
  /** @deprecated Use `NKinds.addressable()` instead. */
  static parameterizedReplaceable(kind) {
    return _NKinds.addressable(kind);
  }
};

// node_modules/@nostrify/nostrify/dist/utils/CircularSet.js
var CircularSet = class {
  constructor(capacity) {
    __publicField(this, "set");
    __publicField(this, "capacity");
    this.set = /* @__PURE__ */ new Set();
    this.capacity = capacity;
  }
  add(item) {
    if (this.set.has(item)) {
      return;
    }
    if (this.set.size >= this.capacity) {
      const oldest = this.set.values().next().value;
      if (oldest) {
        this.set.delete(oldest);
      }
    }
    this.set.add(item);
  }
  has(item) {
    return this.set.has(item);
  }
  [Symbol.iterator]() {
    return this.set.values();
  }
};

// node_modules/@nostrify/nostrify/dist/utils/Machina.js
var _queue, _resolve, _aborted;
var Machina = class {
  constructor(signal) {
    __privateAdd(this, _queue, []);
    __privateAdd(this, _resolve);
    __privateAdd(this, _aborted, false);
    if (signal == null ? void 0 : signal.aborted) {
      this.abort();
    } else {
      signal == null ? void 0 : signal.addEventListener("abort", () => this.abort(), { once: true });
    }
  }
  /** Get messages as an AsyncIterable. */
  async *[Symbol.asyncIterator]() {
    while (!__privateGet(this, _aborted)) {
      if (__privateGet(this, _queue).length) {
        yield __privateGet(this, _queue).shift();
        continue;
      }
      await new Promise((_resolve2) => {
        __privateSet(this, _resolve, _resolve2);
      });
    }
    throw new DOMException("The signal has been aborted", "AbortError");
  }
  /** Push a message into the Machina instance, making it available to the consumer of `stream()`. */
  push(data) {
    var _a5;
    __privateGet(this, _queue).push(data);
    (_a5 = __privateGet(this, _resolve)) == null ? void 0 : _a5.call(this);
  }
  /** Stops streaming and throws an error to the consumer. */
  abort() {
    var _a5;
    __privateSet(this, _aborted, true);
    (_a5 = __privateGet(this, _resolve)) == null ? void 0 : _a5.call(this);
  }
};
_queue = new WeakMap();
_resolve = new WeakMap();
_aborted = new WeakMap();

// node_modules/@nostrify/nostrify/dist/NPool.js
var NPool = class _NPool {
  constructor(opts) {
    __publicField(this, "_relays", /* @__PURE__ */ new Map());
    __publicField(this, "opts");
    this.opts = opts;
  }
  /** Get or create a relay instance for the given URL. */
  relay(url) {
    const relay = this._relays.get(url);
    if (relay) {
      return relay;
    } else {
      const relay2 = this.opts.open(url);
      this._relays.set(url, relay2);
      return relay2;
    }
  }
  /** Returns a new pool instance that uses the given relays. Connections are shared with the original pool. */
  group(urls) {
    return new _NPool({
      open: (url) => this.relay(url),
      reqRouter: (filters) => new Map(urls.map((url) => [url, filters])),
      eventRouter: () => urls
    });
  }
  get relays() {
    return this._relays;
  }
  /**
   * Sends a `REQ` to relays based on the configured `reqRouter`.
   *
   * `EVENT` messages from the selected relays are yielded.
   * `EOSE` and `CLOSE` messages are only yielded when all relays have emitted them.
   *
   * Deduplication of `EVENT` messages is attempted, so that each event is only yielded once.
   * A circular set of 1000 is used to track seen event IDs, so it's possible that very
   * long-running subscriptions (with over 1000 results) may yield duplicate events.
   */
  async *req(filters, opts) {
    const controller = new AbortController();
    const signal = (opts == null ? void 0 : opts.signal) ? AbortSignal.any([opts.signal, controller.signal]) : controller.signal;
    const routes = (opts == null ? void 0 : opts.relays) ? new Map(opts.relays.map((url) => [url, filters])) : await this.opts.reqRouter(filters);
    if (routes.size < 1) {
      return;
    }
    const machina = new Machina(signal);
    const eoses = /* @__PURE__ */ new Set();
    const closes = /* @__PURE__ */ new Set();
    const events = new CircularSet(1e3);
    const relayPromises = [];
    for (const [url, filters2] of routes.entries()) {
      const relay = this.relay(url);
      const relayPromise = (async () => {
        try {
          for await (const msg of relay.req(filters2, { signal })) {
            if (msg[0] === "EOSE") {
              eoses.add(url);
              if (eoses.size === routes.size) {
                machina.push(msg);
              }
            }
            if (msg[0] === "CLOSED") {
              closes.add(url);
              if (closes.size === routes.size) {
                machina.push(msg);
              }
            }
            if (msg[0] === "EVENT") {
              const [, , event] = msg;
              if (!events.has(event.id)) {
                events.add(event.id);
                machina.push(msg);
              }
            }
          }
        } catch {
        }
      })();
      relayPromises.push(relayPromise);
    }
    try {
      for await (const msg of machina) {
        yield msg;
      }
    } finally {
      controller.abort();
      await Promise.allSettled(relayPromises);
    }
  }
  /**
   * Events are sent to relays according to the `eventRouter`.
   * Returns a fulfilled promise if ANY relay accepted the event,
   * or a rejected promise if ALL relays rejected or failed to publish the event.
   */
  async event(event, opts) {
    const relayUrls = (opts == null ? void 0 : opts.relays) ?? await this.opts.eventRouter(event);
    if (!relayUrls.length) {
      return;
    }
    await Promise.any(
      relayUrls.map((url) => this.relay(url).event(event, opts))
    );
  }
  /**
   * This method calls `.req` internally and then post-processes the results.
   * Please read the definition of `.req`.
   *
   * - The strategy is to seek regular events quickly, and to wait to find the latest versions of replaceable events.
   * - Filters for replaceable events will wait for all relays to `EOSE` (or `CLOSE`, or for the signal to be aborted) to ensure the latest event versions are retrieved.
   * - Filters for regular events will stop as soon as the filters are fulfilled.
   * - Events are deduplicated, sorted, and only the latest version of replaceable events is kept.
   * - If the signal is aborted, this method will return partial results instead of throwing.
   *
   * To implement a custom strategy, call `.req` directly.
   */
  async query(filters, opts) {
    const map = /* @__PURE__ */ new Map();
    const events = new NSet(map);
    const limit = filters.reduce(
      (result, filter) => result + getFilterLimit(filter),
      0
    );
    if (limit === 0) return [];
    try {
      for await (const msg of this.req(filters, opts)) {
        if (msg[0] === "EOSE") break;
        if (msg[0] === "EVENT") events.add(msg[2]);
        if (msg[0] === "CLOSED") break;
      }
    } catch {
    }
    if (filters.some((filter) => typeof filter.search === "string")) {
      return [...map.values()];
    } else {
      return [...events];
    }
  }
  /** Close all the relays in the pool. */
  async close() {
    await Promise.all(
      [...this._relays.values()].map((relay) => relay.close())
    );
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
};

// node_modules/websocket-ts/dist/esm/src/backoff/exponentialbackoff.js
var ExponentialBackoff = class {
  /**
   * Creates a new ExponentialBackoff.
   * @param base the base of the exponentiation
   * @param expMax the maximum exponent, no bound if undefined
   */
  constructor(base, expMax) {
    this._retries = 0;
    if (!Number.isInteger(base) || base < 0) {
      throw new Error("Base must be a positive integer or zero");
    }
    if (expMax !== void 0 && (!Number.isInteger(expMax) || expMax < 0)) {
      throw new Error("ExpMax must be a undefined, a positive integer or zero");
    }
    this.base = base;
    this.expMax = expMax;
    this.i = 0;
  }
  get retries() {
    return this._retries;
  }
  get current() {
    return this.base * Math.pow(2, this.i);
  }
  next() {
    this._retries++;
    this.i = this.expMax === void 0 ? this.i + 1 : Math.min(this.i + 1, this.expMax);
    return this.current;
  }
  reset() {
    this._retries = 0;
    this.i = 0;
  }
};

// node_modules/websocket-ts/dist/esm/src/queue/array_queue.js
var ArrayQueue = class {
  constructor() {
    this.elements = [];
  }
  add(element) {
    this.elements.push(element);
  }
  clear() {
    this.elements.length = 0;
  }
  forEach(fn) {
    this.elements.forEach(fn);
  }
  length() {
    return this.elements.length;
  }
  isEmpty() {
    return this.elements.length === 0;
  }
  peek() {
    return this.elements[0];
  }
  read() {
    return this.elements.shift();
  }
};

// node_modules/websocket-ts/dist/esm/src/websocket_event.js
var WebsocketEvent;
(function(WebsocketEvent2) {
  WebsocketEvent2["open"] = "open";
  WebsocketEvent2["close"] = "close";
  WebsocketEvent2["error"] = "error";
  WebsocketEvent2["message"] = "message";
  WebsocketEvent2["retry"] = "retry";
  WebsocketEvent2["reconnect"] = "reconnect";
})(WebsocketEvent || (WebsocketEvent = {}));

// node_modules/websocket-ts/dist/esm/src/websocket.js
var Websocket = class {
  /**
   * Creates a new websocket.
   *
   * @param url to connect to.
   * @param protocols optional protocols to use.
   * @param options optional options to use.
   */
  constructor(url, protocols, options) {
    var _a5, _b4, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    this._closedByUser = false;
    this.handleOpenEvent = (event) => this.handleEvent(WebsocketEvent.open, event);
    this.handleErrorEvent = (event) => this.handleEvent(WebsocketEvent.error, event);
    this.handleCloseEvent = (event) => this.handleEvent(WebsocketEvent.close, event);
    this.handleMessageEvent = (event) => this.handleEvent(WebsocketEvent.message, event);
    this._url = url;
    this._protocols = protocols;
    this._options = {
      buffer: options === null || options === void 0 ? void 0 : options.buffer,
      retry: {
        maxRetries: (_a5 = options === null || options === void 0 ? void 0 : options.retry) === null || _a5 === void 0 ? void 0 : _a5.maxRetries,
        instantReconnect: (_b4 = options === null || options === void 0 ? void 0 : options.retry) === null || _b4 === void 0 ? void 0 : _b4.instantReconnect,
        backoff: (_c = options === null || options === void 0 ? void 0 : options.retry) === null || _c === void 0 ? void 0 : _c.backoff
      },
      listeners: {
        open: [...(_e = (_d = options === null || options === void 0 ? void 0 : options.listeners) === null || _d === void 0 ? void 0 : _d.open) !== null && _e !== void 0 ? _e : []],
        close: [...(_g = (_f = options === null || options === void 0 ? void 0 : options.listeners) === null || _f === void 0 ? void 0 : _f.close) !== null && _g !== void 0 ? _g : []],
        error: [...(_j = (_h = options === null || options === void 0 ? void 0 : options.listeners) === null || _h === void 0 ? void 0 : _h.error) !== null && _j !== void 0 ? _j : []],
        message: [...(_l = (_k = options === null || options === void 0 ? void 0 : options.listeners) === null || _k === void 0 ? void 0 : _k.message) !== null && _l !== void 0 ? _l : []],
        retry: [...(_o = (_m = options === null || options === void 0 ? void 0 : options.listeners) === null || _m === void 0 ? void 0 : _m.retry) !== null && _o !== void 0 ? _o : []],
        reconnect: [...(_q = (_p = options === null || options === void 0 ? void 0 : options.listeners) === null || _p === void 0 ? void 0 : _p.reconnect) !== null && _q !== void 0 ? _q : []]
      }
    };
    this._underlyingWebsocket = this.tryConnect();
  }
  /**
   * Getter for the url.
   *
   * @return the url.
   */
  get url() {
    return this._url;
  }
  /**
   * Getter for the protocols.
   *
   * @return the protocols, or undefined if none were provided.
   */
  get protocols() {
    return this._protocols;
  }
  /**
   * Getter for the buffer.
   *
   * @return the buffer, or undefined if none was provided.
   */
  get buffer() {
    return this._options.buffer;
  }
  /**
   * Getter for the maxRetries.
   *
   * @return the maxRetries, or undefined if none was provided (no limit).
   */
  get maxRetries() {
    return this._options.retry.maxRetries;
  }
  /**
   * Getter for the instantReconnect.
   *
   * @return the instantReconnect, or undefined if none was provided.
   */
  get instantReconnect() {
    return this._options.retry.instantReconnect;
  }
  /**
   * Getter for the backoff.
   *
   * @return the backoff, or undefined if none was provided.
   */
  get backoff() {
    return this._options.retry.backoff;
  }
  /**
   * Whether the websocket was closed by the user. A websocket is closed by the user by calling close().
   *
   * @return true if the websocket was closed by the user, false otherwise.
   */
  get closedByUser() {
    return this._closedByUser;
  }
  /**
   * Getter for the last 'open' event, e.g. the last time the websocket was connected.
   *
   * @return the last 'open' event, or undefined if the websocket was never connected.
   */
  get lastConnection() {
    return this._lastConnection;
  }
  /**
   * Getter for the underlying websocket. This can be used to access the browser's native websocket directly.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
   * @return the underlying websocket.
   */
  get underlyingWebsocket() {
    return this._underlyingWebsocket;
  }
  /**
   * Getter for the readyState of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
   * @return the readyState of the underlying websocket.
   */
  get readyState() {
    return this._underlyingWebsocket.readyState;
  }
  /**
   * Getter for the bufferedAmount of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount
   * @return the bufferedAmount of the underlying websocket.
   */
  get bufferedAmount() {
    return this._underlyingWebsocket.bufferedAmount;
  }
  /**
   * Getter for the extensions of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions
   * @return the extensions of the underlying websocket.
   */
  get extensions() {
    return this._underlyingWebsocket.extensions;
  }
  /**
   * Getter for the binaryType of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType
   * @return the binaryType of the underlying websocket.
   */
  get binaryType() {
    return this._underlyingWebsocket.binaryType;
  }
  /**
   * Setter for the binaryType of the underlying websocket.
   *
   * @param value to set, 'blob' or 'arraybuffer'.
   */
  set binaryType(value) {
    this._underlyingWebsocket.binaryType = value;
  }
  /**
   * Sends data over the websocket.
   *
   * If the websocket is not connected and a buffer was provided on creation, the data will be added to the buffer.
   * If no buffer was provided or the websocket was closed by the user, the data will be dropped.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   * @param data to send.
   */
  send(data) {
    if (this.closedByUser)
      return;
    if (this._underlyingWebsocket.readyState === this._underlyingWebsocket.OPEN) {
      this._underlyingWebsocket.send(data);
    } else if (this.buffer !== void 0) {
      this.buffer.add(data);
    }
  }
  /**
   * Close the websocket. No connection-retry will be attempted after this.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close
   * @param code optional close code.
   * @param reason optional close reason.
   */
  close(code, reason) {
    this.cancelScheduledConnectionRetry();
    this._closedByUser = true;
    this._underlyingWebsocket.close(code, reason);
  }
  /**
   * Adds an event listener for the given event-type.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   * @param type of the event to add the listener for.
   * @param listener to add.
   * @param options to use when adding the listener.
   */
  addEventListener(type, listener, options) {
    this._options.listeners[type].push({ listener, options });
  }
  /**
   * Removes one or more event listener for the given event-type that match the given listener and options.
   *
   * @param type of the event to remove the listener for.
   * @param listener to remove.
   * @param options that were used when the listener was added.
   */
  removeEventListener(type, listener, options) {
    const isListenerNotToBeRemoved = (l) => l.listener !== listener || l.options !== options;
    this._options.listeners[type] = this._options.listeners[type].filter(isListenerNotToBeRemoved);
  }
  /**
   * Creates a new browser-native websocket and connects it to the given URL with the given protocols
   * and adds all event listeners to the browser-native websocket.
   *
   * @return the created browser-native websocket which is also stored in the '_underlyingWebsocket' property.
   */
  tryConnect() {
    this._underlyingWebsocket = new WebSocket(this.url, this.protocols);
    this._underlyingWebsocket.addEventListener(WebsocketEvent.open, this.handleOpenEvent);
    this._underlyingWebsocket.addEventListener(WebsocketEvent.close, this.handleCloseEvent);
    this._underlyingWebsocket.addEventListener(WebsocketEvent.error, this.handleErrorEvent);
    this._underlyingWebsocket.addEventListener(WebsocketEvent.message, this.handleMessageEvent);
    return this._underlyingWebsocket;
  }
  /**
   * Removes all event listeners from the browser-native websocket and closes it.
   */
  clearWebsocket() {
    this._underlyingWebsocket.removeEventListener(WebsocketEvent.open, this.handleOpenEvent);
    this._underlyingWebsocket.removeEventListener(WebsocketEvent.close, this.handleCloseEvent);
    this._underlyingWebsocket.removeEventListener(WebsocketEvent.error, this.handleErrorEvent);
    this._underlyingWebsocket.removeEventListener(WebsocketEvent.message, this.handleMessageEvent);
    this._underlyingWebsocket.close();
  }
  /**
   * Dispatch an event to all listeners of the given event-type.
   *
   * @param type of the event to dispatch.
   * @param event to dispatch.
   */
  dispatchEvent(type, event) {
    const eventListeners = this._options.listeners[type];
    const newEventListeners = [];
    eventListeners.forEach(({ listener, options }) => {
      listener(this, event);
      if (options === void 0 || options.once === void 0 || !options.once) {
        newEventListeners.push({ listener, options });
      }
    });
    this._options.listeners[type] = newEventListeners;
  }
  /**
   * Handles the given event by dispatching it to all listeners of the given event-type.
   *
   * @param type of the event to handle.
   * @param event to handle.
   */
  handleEvent(type, event) {
    switch (type) {
      case WebsocketEvent.close:
        this.dispatchEvent(type, event);
        this.scheduleConnectionRetryIfNeeded();
        break;
      case WebsocketEvent.open:
        if (this.backoff !== void 0 && this._lastConnection !== void 0) {
          const detail = {
            retries: this.backoff.retries,
            lastConnection: new Date(this._lastConnection)
          };
          const event2 = new CustomEvent(WebsocketEvent.reconnect, {
            detail
          });
          this.dispatchEvent(WebsocketEvent.reconnect, event2);
          this.backoff.reset();
        }
        this._lastConnection = /* @__PURE__ */ new Date();
        this.dispatchEvent(type, event);
        this.sendBufferedData();
        break;
      case WebsocketEvent.retry:
        this.dispatchEvent(type, event);
        this.clearWebsocket();
        this.tryConnect();
        break;
      default:
        this.dispatchEvent(type, event);
        break;
    }
  }
  /**
   * Sends buffered data if there is a buffer defined.
   */
  sendBufferedData() {
    if (this.buffer === void 0) {
      return;
    }
    for (let ele = this.buffer.read(); ele !== void 0; ele = this.buffer.read()) {
      this.send(ele);
    }
  }
  /**
   * Schedules a connection-retry if there is a backoff defined and the websocket was not closed by the user.
   */
  scheduleConnectionRetryIfNeeded() {
    if (this.closedByUser) {
      return;
    }
    if (this.backoff === void 0) {
      return;
    }
    const handleRetryEvent = (detail) => {
      const event = new CustomEvent(WebsocketEvent.retry, { detail });
      this.handleEvent(WebsocketEvent.retry, event);
    };
    const retryEventDetail = {
      backoff: this._options.retry.instantReconnect === true ? 0 : this.backoff.next(),
      retries: this._options.retry.instantReconnect === true ? 0 : this.backoff.retries,
      lastConnection: this._lastConnection
    };
    if (this._options.retry.maxRetries === void 0 || retryEventDetail.retries <= this._options.retry.maxRetries) {
      this.retryTimeout = globalThis.setTimeout(() => handleRetryEvent(retryEventDetail), retryEventDetail.backoff);
    }
  }
  /**
   * Cancels the scheduled connection-retry, if there is one.
   */
  cancelScheduledConnectionRetry() {
    globalThis.clearTimeout(this.retryTimeout);
  }
};

// node_modules/websocket-ts/dist/esm/src/websocket_builder.js
var WebsocketBuilder = class {
  /**
   * Creates a new WebsocketBuilder.
   *
   * @param url the url to connect to
   */
  constructor(url) {
    this._url = url;
  }
  /**
   * Getter for the url.
   *
   * @returns the url
   */
  get url() {
    return this._url;
  }
  /**
   * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.
   *
   * @param protocols the protocols to add
   */
  withProtocols(protocols) {
    this._protocols = protocols;
    return this;
  }
  /**
   * Getter for the protocols.
   *
   * @returns the protocols, undefined if no protocols have been set
   */
  get protocols() {
    return this._protocols;
  }
  /**
   * Sets the maximum number of retries before giving up. No limit if undefined.
   *
   * @param maxRetries the maximum number of retries before giving up
   */
  withMaxRetries(maxRetries) {
    var _a5;
    this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.retry), { maxRetries }) });
    return this;
  }
  /**
   * Getter for the maximum number of retries before giving up.
   *
   * @returns the maximum number of retries before giving up, undefined if no maximum has been set
   */
  get maxRetries() {
    var _a5, _b4;
    return (_b4 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.retry) === null || _b4 === void 0 ? void 0 : _b4.maxRetries;
  }
  /**
   * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
   *
   * @param instantReconnect wether to reconnect immediately after a connection has been lost
   */
  withInstantReconnect(instantReconnect) {
    var _a5;
    this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.retry), { instantReconnect }) });
    return this;
  }
  /**
   * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
   *
   * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set
   */
  get instantReconnect() {
    var _a5, _b4;
    return (_b4 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.retry) === null || _b4 === void 0 ? void 0 : _b4.instantReconnect;
  }
  /**
   * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.
   *
   * @param backoff the backoff to add
   */
  withBackoff(backoff) {
    var _a5;
    this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.retry), { backoff }) });
    return this;
  }
  /**
   * Getter for the backoff.
   *
   * @returns the backoff, undefined if no backoff has been set
   */
  get backoff() {
    var _a5, _b4;
    return (_b4 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.retry) === null || _b4 === void 0 ? void 0 : _b4.backoff;
  }
  /**
   * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.
   *
   * @param buffer the buffer to add
   */
  withBuffer(buffer) {
    this._options = Object.assign(Object.assign({}, this._options), { buffer });
    return this;
  }
  /**
   * Getter for the buffer.
   *
   * @returns the buffer, undefined if no buffer has been set
   */
  get buffer() {
    var _a5;
    return (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.buffer;
  }
  /**
   * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onOpen(listener, options) {
    this.addListener(WebsocketEvent.open, listener, options);
    return this;
  }
  /**
   * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onClose(listener, options) {
    this.addListener(WebsocketEvent.close, listener, options);
    return this;
  }
  /**
   * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onError(listener, options) {
    this.addListener(WebsocketEvent.error, listener, options);
    return this;
  }
  /**
   * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onMessage(listener, options) {
    this.addListener(WebsocketEvent.message, listener, options);
    return this;
  }
  /**
   * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onRetry(listener, options) {
    this.addListener(WebsocketEvent.retry, listener, options);
    return this;
  }
  /**
   * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onReconnect(listener, options) {
    this.addListener(WebsocketEvent.reconnect, listener, options);
    return this;
  }
  /**
   * Builds the websocket.
   *
   * @return a new websocket, with the set options
   */
  build() {
    return new Websocket(this._url, this._protocols, this._options);
  }
  /**
   * Adds an event listener to the options.
   *
   * @param event the event to add the listener to
   * @param listener the listener to add
   * @param options the listener options
   */
  addListener(event, listener, options) {
    var _a5, _b4, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    this._options = Object.assign(Object.assign({}, this._options), { listeners: {
      open: (_c = (_b4 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.listeners) === null || _b4 === void 0 ? void 0 : _b4.open) !== null && _c !== void 0 ? _c : [],
      close: (_f = (_e = (_d = this._options) === null || _d === void 0 ? void 0 : _d.listeners) === null || _e === void 0 ? void 0 : _e.close) !== null && _f !== void 0 ? _f : [],
      error: (_j = (_h = (_g = this._options) === null || _g === void 0 ? void 0 : _g.listeners) === null || _h === void 0 ? void 0 : _h.error) !== null && _j !== void 0 ? _j : [],
      message: (_m = (_l = (_k = this._options) === null || _k === void 0 ? void 0 : _k.listeners) === null || _l === void 0 ? void 0 : _l.message) !== null && _m !== void 0 ? _m : [],
      retry: (_q = (_p = (_o = this._options) === null || _o === void 0 ? void 0 : _o.listeners) === null || _p === void 0 ? void 0 : _p.retry) !== null && _q !== void 0 ? _q : [],
      reconnect: (_t = (_s = (_r = this._options) === null || _r === void 0 ? void 0 : _r.listeners) === null || _s === void 0 ? void 0 : _s.reconnect) !== null && _t !== void 0 ? _t : [],
      [event]: [
        ...(_w = (_v = (_u = this._options) === null || _u === void 0 ? void 0 : _u.listeners) === null || _v === void 0 ? void 0 : _v[event]) !== null && _w !== void 0 ? _w : [],
        { listener, options }
      ]
    } });
    return this;
  }
};

// node_modules/@nostrify/nostrify/dist/NRelay1.js
var NRelay1 = class {
  constructor(url, opts = {}) {
    __publicField(this, "socket");
    __publicField(this, "subs", /* @__PURE__ */ new Map());
    __publicField(this, "closedByUser", false);
    __publicField(this, "idleTimer");
    __publicField(this, "controller", new AbortController());
    __publicField(this, "url");
    __publicField(this, "opts");
    __publicField(this, "ee", new EventTarget());
    this.url = url;
    this.opts = opts;
    this.socket = this.createSocket();
    this.maybeStartIdleTimer();
  }
  get subscriptions() {
    return [...this.subs.values()];
  }
  log(log) {
    var _a5, _b4;
    (_b4 = (_a5 = this.opts).log) == null ? void 0 : _b4.call(_a5, { ...log, url: this.url });
  }
  /** Create (and open) a WebSocket connection with automatic reconnect. */
  createSocket() {
    const { backoff = new ExponentialBackoff(1e3) } = this.opts;
    return new WebsocketBuilder(this.url).withBuffer(new ArrayQueue()).withBackoff(backoff === false ? void 0 : backoff).onOpen((socket) => {
      this.log({
        level: "debug",
        ns: "relay.ws.state",
        state: "open",
        readyState: socket.readyState
      });
      for (const req of this.subs.values()) {
        this.send(req);
      }
    }).onClose((socket) => {
      this.log({
        level: "debug",
        ns: "relay.ws.state",
        state: "close",
        readyState: socket.readyState
      });
      if (!this.subs.size) {
        this.socket.close();
      }
    }).onReconnect((socket) => {
      this.log({
        level: "debug",
        ns: "relay.ws.state",
        state: "reconnect",
        readyState: socket.readyState
      });
    }).onRetry((socket, e) => {
      this.log({
        level: "warn",
        ns: "relay.ws.retry",
        readyState: socket.readyState,
        backoff: e.detail.backoff
      });
    }).onError((socket) => {
      this.log({
        level: "error",
        ns: "relay.ws.error",
        readyState: socket.readyState
      });
    }).onMessage((_socket, e) => {
      if (typeof e.data !== "string") {
        this.close();
        return;
      }
      const result = NSchema.json().pipe(NSchema.relayMsg()).safeParse(e.data);
      if (result.success) {
        this.log({
          level: "trace",
          ns: "relay.ws.message",
          data: result.data
        });
        this.receive(result.data);
      } else {
        this.log({
          level: "warn",
          ns: "relay.ws.message",
          error: result.error
        });
      }
    }).build();
  }
  /** Handle a NIP-01 relay message. */
  receive(msg) {
    const { auth, verifyEvent: verifyEvent2 = verifyEvent } = this.opts;
    switch (msg[0]) {
      case "EVENT":
        if (!verifyEvent2(msg[2])) break;
        this.ee.dispatchEvent(
          new CustomEvent(`sub:${msg[1]}`, { detail: msg })
        );
        break;
      case "EOSE":
        this.ee.dispatchEvent(
          new CustomEvent(`sub:${msg[1]}`, { detail: msg })
        );
        break;
      case "CLOSED":
        this.subs.delete(msg[1]);
        this.maybeStartIdleTimer();
        this.ee.dispatchEvent(
          new CustomEvent(`sub:${msg[1]}`, { detail: msg })
        );
        this.ee.dispatchEvent(
          new CustomEvent(`count:${msg[1]}`, { detail: msg })
        );
        break;
      case "OK":
        this.ee.dispatchEvent(new CustomEvent(`ok:${msg[1]}`, { detail: msg }));
        break;
      case "NOTICE":
        this.ee.dispatchEvent(new CustomEvent("notice", { detail: msg }));
        break;
      case "COUNT":
        this.ee.dispatchEvent(
          new CustomEvent(`count:${msg[1]}`, { detail: msg })
        );
        break;
      case "AUTH":
        auth == null ? void 0 : auth(msg[1]).then((event) => this.send(["AUTH", event])).catch(
          () => {
          }
        );
    }
  }
  /** Send a NIP-01 client message to the relay. */
  send(msg) {
    this.log({ level: "trace", ns: "relay.ws.send", data: msg });
    this.wake();
    switch (msg[0]) {
      case "REQ":
        this.subs.set(msg[1], msg);
        break;
      case "CLOSE":
        this.subs.delete(msg[1]);
        this.maybeStartIdleTimer();
        break;
      case "EVENT":
      case "COUNT":
        return this.socket.send(JSON.stringify(msg));
    }
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(msg));
    }
  }
  async *req(filters, opts = {}) {
    const { signal } = opts;
    const subscriptionId = crypto.randomUUID();
    const msgs = this.on(`sub:${subscriptionId}`, signal);
    const req = ["REQ", subscriptionId, ...filters];
    this.send(req);
    try {
      for await (const msg of msgs) {
        if (msg[0] === "EOSE") yield msg;
        if (msg[0] === "CLOSED") break;
        if (msg[0] === "EVENT") {
          if (matchFilters(filters, msg[2])) {
            yield msg;
          } else {
            continue;
          }
        }
      }
    } finally {
      this.send(["CLOSE", subscriptionId]);
    }
  }
  async query(filters, opts) {
    const events = new NSet();
    const limit = filters.reduce(
      (result, filter) => result + getFilterLimit(filter),
      0
    );
    if (limit === 0) return [];
    for await (const msg of this.req(filters, opts)) {
      if (msg[0] === "EOSE") break;
      if (msg[0] === "EVENT") events.add(msg[2]);
      if (msg[0] === "CLOSED") throw new Error("Subscription closed");
      if (events.size >= limit) {
        break;
      }
    }
    return [...events];
  }
  async event(event, opts) {
    const result = this.once(`ok:${event.id}`, opts == null ? void 0 : opts.signal);
    try {
      this.send(["EVENT", event]);
    } catch (e) {
      result.catch(() => {
      });
      throw e;
    }
    const [, , ok, reason] = await result;
    if (!ok) {
      throw new Error(reason);
    }
  }
  async count(filters, opts) {
    const subscriptionId = crypto.randomUUID();
    const result = this.once(`count:${subscriptionId}`, opts == null ? void 0 : opts.signal);
    try {
      this.send(["COUNT", subscriptionId, ...filters]);
    } catch (e) {
      result.catch(() => {
      });
      throw e;
    }
    const msg = await result;
    switch (msg[0]) {
      case "CLOSED":
        throw new Error("Subscription closed");
      case "COUNT": {
        const [, , count] = msg;
        return count;
      }
    }
    throw new Error("Count ended -- this should never happen");
  }
  /** Get a stream of EE events. */
  async *on(key, signal) {
    const _signal = signal ? AbortSignal.any([this.controller.signal, signal]) : this.controller.signal;
    if (_signal.aborted) throw this.abortError();
    const machina = new Machina(_signal);
    const onMsg = (e) => machina.push(e.detail);
    this.ee.addEventListener(key, onMsg);
    try {
      for await (const msg of machina) {
        yield msg;
      }
    } finally {
      this.ee.removeEventListener(key, onMsg);
    }
  }
  /** Wait for a single EE event. */
  async once(key, signal) {
    for await (const msg of this.on(key, signal)) {
      return msg;
    }
    throw new Error("Unreachable");
  }
  abortError() {
    return new DOMException("The signal has been aborted", "AbortError");
  }
  /** Start the idle time if applicable. */
  maybeStartIdleTimer() {
    const { idleTimeout = 3e4 } = this.opts;
    if (idleTimeout === false) return;
    if (this.idleTimer) return;
    if (this.subs.size) return;
    if (this.closedByUser) return;
    this.log({
      level: "debug",
      ns: "relay.idletimer",
      state: "running",
      timeout: idleTimeout
    });
    this.idleTimer = setTimeout(() => {
      this.log({
        level: "debug",
        ns: "relay.idletimer",
        state: "aborted",
        timeout: idleTimeout
      });
      this.socket.close();
    }, idleTimeout);
  }
  /** Stop the idle timer. */
  stopIdleTimer() {
    this.log({ level: "debug", ns: "relay.idletimer", state: "stopped" });
    clearTimeout(this.idleTimer);
    this.idleTimer = void 0;
  }
  /** Make a new WebSocket, but only if it was closed by an idle timeout. */
  wake() {
    this.stopIdleTimer();
    if (!this.closedByUser && this.socket.closedByUser) {
      this.log({ level: "debug", ns: "relay.wake", state: "awoken" });
      this.socket = this.createSocket();
    } else if (this.closedByUser || this.socket.closedByUser) {
      this.log({ level: "debug", ns: "relay.wake", state: "closed" });
    } else {
      this.log({ level: "debug", ns: "relay.wake", state: "awake" });
    }
  }
  /**
   * Close the relay connection and prevent it from reconnecting.
   * After this you should dispose of the `NRelay1` instance and create a new one to connect again.
   */
  async close() {
    this.closedByUser = true;
    this.socket.close();
    this.stopIdleTimer();
    this.controller.abort();
    if (this.socket.readyState !== WebSocket.CLOSED) {
      await new Promise((resolve) => {
        this.socket.addEventListener(WebsocketEvent.close, resolve, {
          once: true
        });
      });
    }
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
};

// node_modules/@nostrify/nostrify/dist/NSecSigner.js
var _secretKey, _NSecSigner_instances, getConversationKey_fn;
var NSecSigner = class {
  constructor(secretKey) {
    __privateAdd(this, _NSecSigner_instances);
    __privateAdd(this, _secretKey);
    __publicField(this, "pubkey");
    __publicField(this, "nip04", {
      encrypt: async (pubkey, plaintext) => {
        return nip04_exports.encrypt(__privateGet(this, _secretKey), pubkey, plaintext);
      },
      decrypt: async (pubkey, ciphertext) => {
        return nip04_exports.decrypt(__privateGet(this, _secretKey), pubkey, ciphertext);
      }
    });
    __publicField(this, "nip44", {
      encrypt: async (pubkey, plaintext) => {
        const conversationKey = __privateMethod(this, _NSecSigner_instances, getConversationKey_fn).call(this, pubkey);
        return nip44_exports.v2.encrypt(plaintext, conversationKey);
      },
      decrypt: async (pubkey, ciphertext) => {
        const conversationKey = __privateMethod(this, _NSecSigner_instances, getConversationKey_fn).call(this, pubkey);
        return nip44_exports.v2.decrypt(ciphertext, conversationKey);
      }
    });
    __privateSet(this, _secretKey, secretKey);
  }
  async getPublicKey() {
    return this.pubkey ?? (this.pubkey = getPublicKey(__privateGet(this, _secretKey)));
  }
  async signEvent(event) {
    return finalizeEvent(event, __privateGet(this, _secretKey));
  }
};
_secretKey = new WeakMap();
_NSecSigner_instances = new WeakSet();
getConversationKey_fn = function(pubkey) {
  return nip44_exports.v2.utils.getConversationKey(__privateGet(this, _secretKey), pubkey);
};

// node_modules/@nostrify/nostrify/dist/RelayError.js
var RelayError = class _RelayError extends Error {
  constructor(prefix, message) {
    super(`${prefix}: ${message}`);
  }
  /** Construct a RelayError from the reason message. */
  static fromReason(reason) {
    const [prefix, ...rest] = reason.split(": ");
    return new _RelayError(prefix, rest.join(": "));
  }
  /** Throw a new RelayError if the OK message is false. */
  static assert(msg) {
    const [, , ok, reason] = msg;
    if (!ok) {
      throw _RelayError.fromReason(reason);
    }
  }
};

export {
  BunkerURI,
  NBrowserSigner,
  NSet,
  NCache,
  NConnectSigner,
  NIP05,
  NIP50,
  NIP98Client,
  NKinds,
  NPool,
  NRelay1,
  NSecSigner,
  RelayError
};
//# sourceMappingURL=chunk-V3KPUVO3.js.map
