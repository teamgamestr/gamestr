import {
  v3_exports
} from "./chunk-WVEDXYV7.js";
import {
  verifyEvent
} from "./chunk-RHRR5RQ3.js";

// node_modules/@nostrify/nostrify/dist/NSchema.js
var NSchema = class _NSchema {
  /** Schema to validate Nostr hex IDs such as event IDs and pubkeys. */
  static id() {
    return v3_exports.string().regex(/^[0-9a-f]{64}$/);
  }
  /** Nostr event schema. */
  static event() {
    return v3_exports.object({
      id: _NSchema.id(),
      kind: v3_exports.number().int().nonnegative(),
      pubkey: _NSchema.id(),
      tags: v3_exports.string().array().array(),
      content: v3_exports.string(),
      created_at: v3_exports.number().int().nonnegative(),
      sig: v3_exports.string()
    }).required({
      id: true,
      kind: true,
      pubkey: true,
      tags: true,
      content: true,
      created_at: true,
      sig: true
    });
  }
  /** Nostr filter schema. */
  static filter() {
    return v3_exports.object({
      kinds: v3_exports.number().int().nonnegative().array().optional(),
      ids: _NSchema.id().array().optional(),
      authors: _NSchema.id().array().optional(),
      since: v3_exports.number().int().nonnegative().optional(),
      until: v3_exports.number().int().nonnegative().optional(),
      limit: v3_exports.number().int().nonnegative().optional(),
      search: v3_exports.string().optional()
    }).passthrough().transform((value) => {
      const keys = [
        "kinds",
        "ids",
        "authors",
        "since",
        "until",
        "limit",
        "search"
      ];
      return Object.entries(value).reduce((acc, [key, val]) => {
        if (keys.includes(key) || key.startsWith("#")) {
          acc[key] = val;
        }
        return acc;
      }, {});
    });
  }
  /**
   * Bech32 string.
   * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32
   */
  static bech32(prefix) {
    return v3_exports.string().regex(/^[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}$/).refine(
      (value) => prefix ? value.startsWith(`${prefix}1`) : true
    );
  }
  /** WebSocket URL starting with `ws://` or `wss://`. */
  static relayUrl() {
    return v3_exports.string().url().regex(/^wss?:\/\//);
  }
  /** NIP-01 `EVENT` message from client to relay. */
  static clientEVENT() {
    return v3_exports.tuple([
      v3_exports.literal("EVENT"),
      _NSchema.event()
    ]);
  }
  /** NIP-01 `REQ` message from client to relay. */
  static clientREQ() {
    return v3_exports.tuple([v3_exports.literal("REQ"), v3_exports.string()]).rest(_NSchema.filter());
  }
  /** NIP-45 `COUNT` message from client to relay. */
  static clientCOUNT() {
    return v3_exports.tuple([v3_exports.literal("COUNT"), v3_exports.string()]).rest(_NSchema.filter());
  }
  /** NIP-01 `CLOSE` message from client to relay. */
  static clientCLOSE() {
    return v3_exports.tuple([v3_exports.literal("CLOSE"), v3_exports.string()]);
  }
  /** NIP-42 `AUTH` message from client to relay. */
  static clientAUTH() {
    return v3_exports.tuple([
      v3_exports.literal("AUTH"),
      _NSchema.event()
    ]);
  }
  /** NIP-01 message from client to relay. */
  static clientMsg() {
    return v3_exports.union([
      _NSchema.clientEVENT(),
      _NSchema.clientREQ(),
      _NSchema.clientCOUNT(),
      _NSchema.clientCLOSE(),
      _NSchema.clientAUTH()
    ]);
  }
  /** NIP-01 `EVENT` message from relay to client. */
  static relayEVENT() {
    return v3_exports.tuple([
      v3_exports.literal("EVENT"),
      v3_exports.string(),
      _NSchema.event()
    ]);
  }
  /** NIP-01 `OK` message from relay to client. */
  static relayOK() {
    return v3_exports.tuple([
      v3_exports.literal("OK"),
      _NSchema.id(),
      v3_exports.boolean(),
      v3_exports.string()
    ]);
  }
  /** NIP-01 `EOSE` message from relay to client. */
  static relayEOSE() {
    return v3_exports.tuple([v3_exports.literal("EOSE"), v3_exports.string()]);
  }
  /** NIP-01 `NOTICE` message from relay to client. */
  static relayNOTICE() {
    return v3_exports.tuple([v3_exports.literal("NOTICE"), v3_exports.string()]);
  }
  /** NIP-01 `CLOSED` message from relay to client. */
  static relayCLOSED() {
    return v3_exports.tuple([
      v3_exports.literal("CLOSED"),
      v3_exports.string(),
      v3_exports.string()
    ]);
  }
  /** NIP-42 `AUTH` message from relay to client. */
  static relayAUTH() {
    return v3_exports.tuple([v3_exports.literal("AUTH"), v3_exports.string()]);
  }
  /** NIP-45 `COUNT` message from relay to client. */
  static relayCOUNT() {
    return v3_exports.tuple([
      v3_exports.literal("COUNT"),
      v3_exports.string(),
      v3_exports.object({
        count: v3_exports.number().int().nonnegative(),
        approximate: v3_exports.boolean().optional()
      })
    ]);
  }
  /** NIP-01 message from relay to client. */
  static relayMsg() {
    return v3_exports.union([
      _NSchema.relayEVENT(),
      _NSchema.relayOK(),
      _NSchema.relayEOSE(),
      _NSchema.relayNOTICE(),
      _NSchema.relayCLOSED(),
      _NSchema.relayAUTH(),
      _NSchema.relayCOUNT()
    ]);
  }
  /** Kind 0 content schema. */
  static metadata() {
    return v3_exports.object({
      about: v3_exports.string().optional().catch(void 0),
      banner: v3_exports.string().url().optional().catch(void 0),
      bot: v3_exports.boolean().optional().catch(void 0),
      display_name: v3_exports.string().optional().catch(void 0),
      lud06: _NSchema.bech32("lnurl").optional().catch(void 0),
      lud16: v3_exports.string().email().optional().catch(void 0),
      name: v3_exports.string().optional().catch(void 0),
      nip05: v3_exports.string().email().optional().catch(void 0),
      picture: v3_exports.string().url().optional().catch(void 0),
      website: v3_exports.string().url().optional().catch(void 0)
    }).passthrough();
  }
  /** NIP-46 request content schema. */
  static connectRequest() {
    return v3_exports.object({
      id: v3_exports.string(),
      method: v3_exports.string(),
      params: v3_exports.string().array()
    });
  }
  /** NIP-46 response content schema. */
  static connectResponse() {
    return v3_exports.object({
      id: v3_exports.string(),
      result: v3_exports.string(),
      error: v3_exports.string().optional()
    });
  }
  /**
   * Helper schema to parse a JSON string. It should then be piped into another schema. For example:
   *
   * ```ts
   * const event = NSchema.json().pipe(NSchema.event()).parse(data);
   * ```
   */
  static json() {
    return v3_exports.string().transform((value, ctx) => {
      try {
        return JSON.parse(value);
      } catch (_e) {
        ctx.addIssue({ code: v3_exports.ZodIssueCode.custom, message: "Invalid JSON" });
        return v3_exports.NEVER;
      }
    });
  }
};

// node_modules/@std/encoding/_validate_binary_like.js
var encoder = new TextEncoder();
function getTypeName(value) {
  var _a;
  const type = typeof value;
  if (type !== "object") {
    return type;
  } else if (value === null) {
    return "null";
  } else {
    return ((_a = value == null ? void 0 : value.constructor) == null ? void 0 : _a.name) ?? "object";
  }
}
function validateBinaryLike(source) {
  if (typeof source === "string") {
    return encoder.encode(source);
  } else if (source instanceof Uint8Array) {
    return source;
  } else if (source instanceof ArrayBuffer) {
    return new Uint8Array(source);
  }
  throw new TypeError(`The input must be a Uint8Array, a string, or an ArrayBuffer. Received a value of the type ${getTypeName(source)}.`);
}

// node_modules/@std/encoding/hex.js
var hexTable = new TextEncoder().encode("0123456789abcdef");
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
function encodeHex(src) {
  const u8 = validateBinaryLike(src);
  const dst = new Uint8Array(u8.length * 2);
  for (let i = 0; i < dst.length; i++) {
    const v = u8[i];
    dst[i * 2] = hexTable[v >> 4];
    dst[i * 2 + 1] = hexTable[v & 15];
  }
  return textDecoder.decode(dst);
}

// node_modules/@std/encoding/base64.js
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encodeBase64(data) {
  const uint8 = validateBinaryLike(data);
  let result = "";
  let i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decodeBase64(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// node_modules/@nostrify/nostrify/dist/utils/N64.js
var N64 = class {
  /** Encode an event as a base64 string. */
  static encodeEvent(event) {
    return encodeBase64(JSON.stringify(event));
  }
  /** Decode an event from a base64 string. Validates the event's structure but does not verify its signature. */
  static decodeEvent(base64) {
    const bytes = decodeBase64(base64);
    const text = new TextDecoder().decode(bytes);
    return NSchema.json().pipe(NSchema.event()).parse(text);
  }
};

// node_modules/@nostrify/nostrify/dist/NIP98.js
var NIP98 = class {
  /** Generate an auth event template from a Request. */
  static async template(request, opts) {
    const {
      validatePayload = ["POST", "PUT", "PATCH"].includes(request.method)
    } = opts ?? {};
    const { method, url } = request;
    const tags = [
      ["method", method],
      ["u", url]
    ];
    if (validatePayload) {
      const buffer = await request.clone().arrayBuffer();
      const digest = await crypto.subtle.digest("SHA-256", buffer);
      tags.push(["payload", encodeHex(digest)]);
    }
    return {
      kind: 27235,
      content: "",
      tags,
      created_at: Math.floor(Date.now() / 1e3)
    };
  }
  /** Compare the auth event with the request, throwing a human-readable error if validation fails. */
  static async verify(request, opts) {
    var _a, _b, _c, _d;
    const {
      maxAge = 6e4,
      validatePayload = ["POST", "PUT", "PATCH"].includes(request.method),
      verifyEvent: verifyEvent2 = verifyEvent
    } = opts ?? {};
    const header = request.headers.get("authorization");
    if (!header) {
      throw new Error("Missing Nostr authorization header");
    }
    const token = (_a = header.match(/^Nostr (.+)$/)) == null ? void 0 : _a[1];
    if (!token) {
      throw new Error("Missing Nostr authorization token");
    }
    const event = N64.decodeEvent(token);
    if (!verifyEvent2(event)) {
      throw new Error("Event signature is invalid");
    }
    const age = Date.now() - event.created_at * 1e3;
    const u = (_b = event.tags.find(([name]) => name === "u")) == null ? void 0 : _b[1];
    const method = (_c = event.tags.find(([name]) => name === "method")) == null ? void 0 : _c[1];
    const payload = (_d = event.tags.find(([name]) => name === "payload")) == null ? void 0 : _d[1];
    if (event.kind !== 27235) {
      throw new Error("Event must be kind 27235");
    }
    if (u !== request.url) {
      throw new Error("Event URL does not match request URL");
    }
    if (method !== request.method) {
      throw new Error("Event method does not match HTTP request method");
    }
    if (age >= maxAge) {
      throw new Error("Event expired");
    }
    if (validatePayload && payload !== void 0) {
      const buffer = await request.clone().arrayBuffer();
      const digest = await crypto.subtle.digest("SHA-256", buffer);
      if (encodeHex(digest) !== payload) {
        throw new Error("Event payload does not match request body");
      }
    }
    return event;
  }
};

export {
  NSchema,
  encodeHex,
  N64,
  NIP98
};
//# sourceMappingURL=chunk-7DLL7TTG.js.map
