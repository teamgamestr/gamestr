export type Attribute = import("@html-eslint/types").Attribute;
export type Tag = import("@html-eslint/types").Tag;
export type ScriptTag = import("@html-eslint/types").ScriptTag;
export type StyleTag = import("@html-eslint/types").StyleTag;
export type AnyNode = import("@html-eslint/types").AnyNode;
export type Line = import("../../types").Line;
export type BaseNode = import("../../types").BaseNode;
export type Text = import("@html-eslint/types").Text;
export type CommentContent = import("@html-eslint/types").CommentContent;
export type Comment = import("@html-eslint/types").Comment;
export type AttributeValue = import("@html-eslint/types").AttributeValue;
export type AttributeKey = import("@html-eslint/types").AttributeKey;
export type TemplateText = import("@html-eslint/types").TemplateText;
export type OpenTemplate = import("@html-eslint/types").OpenTemplate;
export type CloseTemplate = import("@html-eslint/types").CloseTemplate;
export type Range = import("eslint").AST.Range;
export type SourceLocation = import("eslint").AST.SourceLocation;
export type AnyToken = import("@html-eslint/types").AnyToken;
/**
 * @param {Tag | ScriptTag | StyleTag} node
 * @param {string} key
 * @returns {Attribute | undefined}
 */
export function findAttr(node: Tag | ScriptTag | StyleTag, key: string): Attribute | undefined;
/**
 * Checks whether a node's attributes is empty or not.
 * @param {Tag | ScriptTag | StyleTag} node
 * @returns {boolean}
 */
export function isAttributesEmpty(node: Tag | ScriptTag | StyleTag): boolean;
/**
 * Checks whether a node's all tokens are on the same line or not.
 * @param {AnyNode} node A node to check
 * @returns {boolean} `true` if a node's tokens are on the same line, otherwise `false`.
 */
export function isNodeTokensOnSameLine(node: AnyNode): boolean;
/**
 *
 * @param {Text | CommentContent} node
 * @returns {Line[]}
 */
export function splitToLineNodes(node: Text | CommentContent): Line[];
/**
 * Get location between two nodes.
 * @param {{loc: SourceLocation}} before A node placed in before
 * @param {{loc: SourceLocation}} after A node placed in after
 * @returns {SourceLocation} location between two nodes.
 */
export function getLocBetween(before: {
    loc: SourceLocation;
}, after: {
    loc: SourceLocation;
}): SourceLocation;
/**
 * @param {AnyNode} node
 * @param {(node: AnyNode) => boolean} predicate
 * @returns {null | AnyNode}
 */
export function findParent(node: AnyNode, predicate: (node: AnyNode) => boolean): null | AnyNode;
/**
 * @param {BaseNode} node
 * @returns {node is Tag}
 */
export function isTag(node: BaseNode): node is Tag;
/**
 * @param {BaseNode} node
 * @returns {node is Comment}
 */
export function isComment(node: BaseNode): node is Comment;
/**
 * @param {BaseNode} node
 * @returns {node is Text}
 */
export function isText(node: BaseNode): node is Text;
/**
 * @param {BaseNode} node
 * @returns {node is Line}
 */
export function isLine(node: BaseNode): node is Line;
/**
 * @param {BaseNode} node
 * @returns {node is ScriptTag}
 */
export function isScript(node: BaseNode): node is ScriptTag;
/**
 * @param {BaseNode} node
 * @returns {node is StyleTag}
 */
export function isStyle(node: BaseNode): node is StyleTag;
/**
 * @param {(Text | CommentContent)['parts']} parts
 * @param {Range} range
 * @returns {boolean}
 */
export function isOverlapWithTemplates(parts: (Text | CommentContent)["parts"], range: Range): boolean;
/**
 * @param {string} source
 * @returns {string[]}
 */
export function codeToLines(source: string): string[];
/**
 *
 * @param {Range} rangeA
 * @param {Range} rangeB
 * @returns {boolean}
 */
export function isRangesOverlap(rangeA: Range, rangeB: Range): boolean;
/**
 *
 * @param {AnyToken[]} tokens
 * @returns {((CommentContent | Text)['parts'][number])[]}
 */
export function getTemplateTokens(tokens: AnyToken[]): ((CommentContent | Text)["parts"][number])[];
/**
 * @param {AttributeKey | AttributeValue | Text | CommentContent} node
 * @returns {boolean}
 */
export function hasTemplate(node: AttributeKey | AttributeValue | Text | CommentContent): boolean;
//# sourceMappingURL=node.d.ts.map