import { z } from "zod";
import { NSchema as n } from "./NSchema.js";
class NConnectSigner {
  relay;
  pubkey;
  signer;
  timeout;
  encryption;
  constructor({ relay, pubkey, signer, timeout, encryption = "nip44" }) {
    this.relay = relay;
    this.pubkey = pubkey;
    this.signer = signer;
    this.timeout = timeout;
    this.encryption = encryption;
  }
  async getPublicKey() {
    return this.cmd("get_public_key", []);
  }
  async signEvent(event) {
    const result = await this.cmd("sign_event", [JSON.stringify(event)]);
    return n.json().pipe(n.event()).parse(result);
  }
  async getRelays() {
    const result = await this.cmd("get_relays", []);
    return n.json().pipe(
      z.record(
        z.string(),
        z.object({ read: z.boolean(), write: z.boolean() })
      )
    ).parse(result);
  }
  nip04 = {
    encrypt: async (pubkey, plaintext) => {
      return this.cmd("nip04_encrypt", [pubkey, plaintext]);
    },
    decrypt: async (pubkey, ciphertext) => {
      return this.cmd("nip04_decrypt", [pubkey, ciphertext]);
    }
  };
  nip44 = {
    encrypt: async (pubkey, plaintext) => {
      return this.cmd("nip44_encrypt", [pubkey, plaintext]);
    },
    decrypt: async (pubkey, ciphertext) => {
      return this.cmd("nip44_decrypt", [pubkey, ciphertext]);
    }
  };
  /** Send a `connect` command to the relay. It should respond with `ack`. */
  async connect(secret) {
    const params = [this.pubkey];
    if (secret) {
      params.push(secret);
    }
    return this.cmd("connect", params);
  }
  /** Send a `ping` command to the signer. It should respond with `pong`. */
  async ping() {
    return this.cmd("ping", []);
  }
  /** High-level RPC method. Returns the string result, or throws on error. */
  async cmd(method, params) {
    const signal = typeof this.timeout === "number" ? AbortSignal.timeout(this.timeout) : void 0;
    const { result, error } = await this.send(
      { id: crypto.randomUUID(), method, params },
      { signal }
    );
    if (error) {
      throw new Error(error);
    }
    return result;
  }
  /** Low-level send method. Deals directly with connect request/response. */
  async send(request, opts = {}) {
    const { signal } = opts;
    const event = await this.signer.signEvent({
      kind: 24133,
      content: await this.encrypt(this.pubkey, JSON.stringify(request)),
      created_at: Math.floor(Date.now() / 1e3),
      tags: [["p", this.pubkey]]
    });
    const local = await this.signer.getPublicKey();
    const req = this.relay.req(
      [{ kinds: [24133], authors: [this.pubkey], "#p": [local] }],
      { signal }
    );
    const promise = new Promise((resolve, reject) => {
      (async () => {
        try {
          for await (const msg of req) {
            if (msg[0] === "CLOSED") throw new Error("Subscription closed");
            if (msg[0] === "EVENT") {
              const event2 = msg[2];
              const decrypted = await this.decrypt(this.pubkey, event2.content);
              const response = n.json().pipe(n.connectResponse()).parse(
                decrypted
              );
              if (response.id === request.id) {
                resolve(response);
                return;
              }
            }
          }
        } catch (error) {
          reject(error);
        }
      })();
    });
    await this.relay.event(event, { signal });
    return promise;
  }
  /** Local encrypt depending on settings. */
  async encrypt(pubkey, plaintext) {
    switch (this.encryption) {
      case "nip04":
        return this.signer.nip04.encrypt(pubkey, plaintext);
      case "nip44":
        return this.signer.nip44.encrypt(pubkey, plaintext);
    }
  }
  /** Local decrypt depending on settings. */
  async decrypt(pubkey, ciphertext) {
    switch (this.encryption) {
      case "nip04":
        return this.signer.nip04.decrypt(pubkey, ciphertext);
      case "nip44":
        return this.signer.nip44.decrypt(pubkey, ciphertext);
    }
  }
}
export {
  NConnectSigner
};
