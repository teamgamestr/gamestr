import { encodeHex } from "@std/encoding/hex";
import { z } from "zod";
import { N64 } from "../utils/N64.js";
class BlossomUploader {
  servers;
  signer;
  fetch;
  expiresIn;
  constructor(opts) {
    this.servers = opts.servers;
    this.signer = opts.signer;
    this.fetch = opts.fetch ?? globalThis.fetch.bind(globalThis);
    this.expiresIn = opts.expiresIn ?? 6e4;
  }
  async upload(file, opts) {
    const x = encodeHex(
      await crypto.subtle.digest("SHA-256", await file.arrayBuffer())
    );
    const now = Date.now();
    const expiration = now + this.expiresIn;
    const event = await this.signer.signEvent({
      kind: 24242,
      content: `Upload ${file.name}`,
      created_at: Math.floor(now / 1e3),
      tags: [
        ["t", "upload"],
        ["x", x],
        ["size", file.size.toString()],
        ["expiration", Math.floor(expiration / 1e3).toString()]
      ]
    });
    const authorization = `Nostr ${N64.encodeEvent(event)}`;
    return Promise.any(this.servers.map(async (server) => {
      const url = new URL("/upload", server);
      const response = await this.fetch(url, {
        method: "PUT",
        body: file,
        headers: {
          authorization,
          "content-type": file.type
        },
        signal: opts?.signal
      });
      const json = await response.json();
      const data = BlossomUploader.schema().parse(json);
      const tags = [
        ["url", data.url],
        ["x", data.sha256],
        ["ox", data.sha256],
        ["size", data.size.toString()]
      ];
      if (data.type) {
        tags.push(["m", data.type]);
      }
      return tags;
    }));
  }
  /** Blossom "BlobDescriptor" schema. */
  static schema() {
    return z.object({
      url: z.string(),
      sha256: z.string(),
      size: z.number(),
      type: z.string().optional()
    });
  }
}
export {
  BlossomUploader
};
