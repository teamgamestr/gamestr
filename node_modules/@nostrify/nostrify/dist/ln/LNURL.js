import { bech32 } from "@scure/base";
import { NSchema as n, z } from "../NSchema.js";
class LNURL {
  /** Underlying HTTP(s) URL of the user. */
  url;
  /** Fetch function to use for HTTP requests. */
  fetch;
  constructor(url, opts) {
    this.url = url;
    this.fetch = opts?.fetch ?? globalThis.fetch.bind(globalThis);
  }
  /**
   * Create an LNURL object from a bech32 `lnurl1...` string.
   * Throws if the value is not a valid lnurl.
   */
  static fromString(value, opts) {
    if (!n.bech32().safeParse(value).success) {
      throw new Error('Expected a bech32 string starting with "lnurl1"');
    }
    const { prefix, words } = bech32.decode(
      value,
      2e4
    );
    if (prefix !== "lnurl") {
      throw new Error('Expected a bech32 string starting with "lnurl1"');
    }
    const data = bech32.fromWords(words);
    const url = new URL(new TextDecoder().decode(data));
    return new LNURL(url, opts);
  }
  /**
   * Create an LNURL object from a lightning address (email-like format).
   * Throws if the value is not a valid lightning address.
   */
  static fromLightningAddress(ln, opts) {
    if (!z.string().email().safeParse(ln).success) {
      throw new Error(
        'Expected a lightning address in email-like format (eg "example@getalby.com")'
      );
    }
    const [name, host] = ln.split("@");
    const url = new URL(`/.well-known/lnurlp/${name}`, `https://${host}`);
    return new LNURL(url, opts);
  }
  /** Returns the LNURL object as a bech32-encoded `lnurl1...` string. */
  toString() {
    const data = new TextEncoder().encode(this.url.toString());
    const words = bech32.toWords(data);
    return bech32.encode("lnurl", words, 2e4);
  }
  /** Resolve an LNURL to its details. */
  async getDetails(opts) {
    const response = await this.fetch(this.url, opts);
    const json = await response.json();
    return LNURL.lnurlDetailsSchema().parse(json);
  }
  /** Generate an LNURL invoice from the params. */
  async getInvoice(opts) {
    const details = await this.getDetails(opts);
    const callback = new URL(details.callback);
    callback.searchParams.set("amount", opts.amount.toString());
    callback.searchParams.set("lnurl", this.toString());
    if (opts.nostr) {
      callback.searchParams.set("nostr", JSON.stringify(opts.nostr));
    }
    const response = await this.fetch(callback, opts);
    const json = await response.json();
    return LNURL.lnurlCallbackSchema().parse(json);
  }
  /** LNURL response schema. */
  static lnurlDetailsSchema() {
    return z.object({
      allowsNostr: z.boolean().optional(),
      callback: z.string().url(),
      commentAllowed: z.number().nonnegative().int().optional(),
      maxSendable: z.number().positive().int(),
      minSendable: z.number().positive().int(),
      metadata: z.string(),
      nostrPubkey: n.id().optional(),
      tag: z.literal("payRequest")
    }).superRefine((details, ctx) => {
      if (details.minSendable > details.maxSendable) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "minSendable must be less than or equal to maxSendable",
          path: ["minSendable"]
        });
      }
    });
  }
  /** LNURL callback schema. */
  static lnurlCallbackSchema() {
    return z.object({
      pr: n.bech32("lnbc"),
      routes: z.tuple([])
    });
  }
}
export {
  LNURL
};
