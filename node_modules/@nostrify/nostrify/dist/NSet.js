class NSet {
  cache;
  constructor(map) {
    this.cache = map ?? /* @__PURE__ */ new Map();
  }
  get size() {
    return this.cache.size;
  }
  add(event) {
    this.#processDeletions(event);
    for (const e of this) {
      if (NSet.deletes(e, event) || NSet.replaces(e, event)) {
        return this;
      } else if (NSet.replaces(event, e)) {
        this.delete(e);
      }
    }
    this.cache.set(event.id, event);
    return this;
  }
  #processDeletions(event) {
    if (event.kind === 5) {
      for (const tag of event.tags) {
        if (tag[0] === "e") {
          const e = this.cache.get(tag[1]);
          if (e && e.pubkey === event.pubkey) {
            this.delete(e);
          }
        }
      }
    }
  }
  clear() {
    this.cache.clear();
  }
  delete(event) {
    return this.cache.delete(event.id);
  }
  forEach(callbackfn, thisArg) {
    return this.cache.forEach(
      (event, _id) => callbackfn(event, event, this),
      thisArg
    );
  }
  has(event) {
    return this.cache.has(event.id);
  }
  *entries() {
    for (const event of this.values()) {
      yield [event, event];
    }
  }
  keys() {
    return this.values();
  }
  *values() {
    for (const event of NSet.sortEvents([...this.cache.values()])) {
      yield event;
    }
  }
  [Symbol.iterator]() {
    return this.values();
  }
  [Symbol.toStringTag] = "NSet";
  /** Event kind is **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */
  static isReplaceable(kind) {
    return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
  }
  /** Event kind is **parameterized replaceable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */
  static isAddressable(kind) {
    return 3e4 <= kind && kind < 4e4;
  }
  /**
   * Returns true if `event` replaces `target`.
   *
   * Both events must be replaceable, belong to the same kind and pubkey (and `d` tag, for parameterized events), and the `event` must be newer than the `target`.
   */
  static replaces(event, target) {
    const { kind, pubkey } = event;
    if (NSet.isReplaceable(kind)) {
      return kind === target.kind && pubkey === target.pubkey && NSet.sortEvents([event, target])[0] === event;
    }
    if (NSet.isAddressable(kind)) {
      const d1 = event.tags.find(([name]) => name === "d")?.[1] || "";
      const d2 = target.tags.find(([name]) => name === "d")?.[1] || "";
      return kind === target.kind && pubkey === target.pubkey && NSet.sortEvents([event, target])[0] === event && d1 === d2;
    }
    return false;
  }
  /**
   * Returns true if the `event` deletes`target`.
   *
   * `event` must be a kind `5` event, and both events must share the same `pubkey`.
   */
  static deletes(event, target) {
    const { kind, pubkey, tags } = event;
    if (kind === 5 && pubkey === target.pubkey) {
      for (const [name, value] of tags) {
        if (name === "e" && value === target.id) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Sort events in reverse-chronological order by the `created_at` timestamp,
   * and then by the event `id` (lexicographically) in case of ties.
   * This mutates the array.
   */
  static sortEvents(events) {
    return events.sort((a, b) => {
      if (a.created_at !== b.created_at) {
        return b.created_at - a.created_at;
      }
      return a.id.localeCompare(b.id);
    });
  }
  union(_other) {
    throw new Error("Method not implemented.");
  }
  intersection(_other) {
    throw new Error("Method not implemented.");
  }
  difference(_other) {
    throw new Error("Method not implemented.");
  }
  symmetricDifference(_other) {
    throw new Error("Method not implemented.");
  }
  isSubsetOf(_other) {
    throw new Error("Method not implemented.");
  }
  isSupersetOf(_other) {
    throw new Error("Method not implemented.");
  }
  isDisjointFrom(_other) {
    throw new Error("Method not implemented.");
  }
}
export {
  NSet
};
