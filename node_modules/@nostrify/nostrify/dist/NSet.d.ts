import type { NostrEvent } from '@nostrify/types';
/**
 * Nostr event implementation of the `Set` interface.
 *
 * NSet is an implementation of the theory that a Nostr Storage is actually just a Set.
 * Events are Nostr's only data type, and they are immutable, making the Set interface ideal.
 *
 * ```ts
 * const events = new NSet();
 *
 * // Events can be added like a regular `Set`:
 * events.add(event1);
 * events.add(event2);
 *
 * // Can be iterated:
 * for (const event of events) {
 *   if (matchFilters(filters, event)) {
 *     console.log(event);
 *   }
 * }
 * ```
 *
 * `NSet` will handle kind `5` deletions, removing events from the set.
 * Replaceable (and parameterized) events will keep only the newest version.
 * However, verification of `id` and `sig` is NOT performed.
 *
 * Any `Map` instance can be passed into `new NSet()`, making it compatible with
 * [lru-cache](https://www.npmjs.com/package/lru-cache), among others.
 */
declare class NSet {
    #private;
    protected cache: Map<string, NostrEvent>;
    constructor(map?: Map<string, NostrEvent>);
    get size(): number;
    add(event: NostrEvent): this;
    clear(): void;
    delete(event: NostrEvent): boolean;
    forEach(callbackfn: (event: NostrEvent, key: NostrEvent, set: typeof this) => void, thisArg?: any): void;
    has(event: NostrEvent): boolean;
    entries(): IterableIterator<[NostrEvent, NostrEvent]>;
    keys(): IterableIterator<NostrEvent>;
    values(): IterableIterator<NostrEvent>;
    [Symbol.iterator](): IterableIterator<NostrEvent>;
    [Symbol.toStringTag]: string;
    /** Event kind is **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */
    protected static isReplaceable(kind: number): boolean;
    /** Event kind is **parameterized replaceable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */
    protected static isAddressable(kind: number): boolean;
    /**
     * Returns true if `event` replaces `target`.
     *
     * Both events must be replaceable, belong to the same kind and pubkey (and `d` tag, for parameterized events), and the `event` must be newer than the `target`.
     */
    protected static replaces(event: NostrEvent, target: NostrEvent): boolean;
    /**
     * Returns true if the `event` deletes`target`.
     *
     * `event` must be a kind `5` event, and both events must share the same `pubkey`.
     */
    protected static deletes(event: NostrEvent, target: NostrEvent): boolean;
    /**
     * Sort events in reverse-chronological order by the `created_at` timestamp,
     * and then by the event `id` (lexicographically) in case of ties.
     * This mutates the array.
     */
    protected static sortEvents(events: NostrEvent[]): NostrEvent[];
    union<U>(_other: Set<U>): Set<NostrEvent | U>;
    intersection<U>(_other: Set<U>): Set<NostrEvent & U>;
    difference<U>(_other: Set<U>): Set<NostrEvent>;
    symmetricDifference<U>(_other: Set<U>): Set<NostrEvent | U>;
    isSubsetOf(_other: Set<unknown>): boolean;
    isSupersetOf(_other: Set<unknown>): boolean;
    isDisjointFrom(_other: Set<unknown>): boolean;
}
export { NSet };
//# sourceMappingURL=NSet.d.ts.map