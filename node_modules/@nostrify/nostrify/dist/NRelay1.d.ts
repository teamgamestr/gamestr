import type { NostrClientMsg, NostrClientREQ, NostrEvent, NostrFilter, NostrRelayCLOSED, NostrRelayEOSE, NostrRelayEVENT, NostrRelayMsg, NRelay } from '@nostrify/types';
import { Websocket } from 'websocket-ts';
import type { Backoff } from 'websocket-ts';
/** Options used for constructing an `NRelay1` instance. */
export interface NRelay1Opts {
    /** Respond to `AUTH` challenges by producing a signed kind `22242` event. */
    auth?(challenge: string): Promise<NostrEvent>;
    /** Configure reconnection strategy, or set to `false` to disable. Default: `new ExponentialBackoff(1000)`. */
    backoff?: Backoff | false;
    /** How long to wait (in milliseconds) for the caller to create a subscription before closing the connection. Set to `false` to disable. Default: `30_000`. */
    idleTimeout?: number | false;
    /** Ensure the event is valid before returning it. Default: `nostrTools.verifyEvent`. */
    verifyEvent?(event: NostrEvent): boolean;
    /** Logger callback. */
    log?(log: NRelay1Log): void;
}
export interface NRelay1Log {
    level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal' | 'critical';
    ns: string;
    [k: string]: JsonValue | undefined | {
        toJSON(): JsonValue;
    } | Error;
}
/** Single relay connection over WebSocket. */
export declare class NRelay1 implements NRelay {
    socket: Websocket;
    private subs;
    private closedByUser;
    private idleTimer?;
    private controller;
    private url;
    private opts;
    private ee;
    get subscriptions(): readonly NostrClientREQ[];
    private log;
    constructor(url: string, opts?: NRelay1Opts);
    /** Create (and open) a WebSocket connection with automatic reconnect. */
    private createSocket;
    /** Handle a NIP-01 relay message. */
    protected receive(msg: NostrRelayMsg): void;
    /** Send a NIP-01 client message to the relay. */
    protected send(msg: NostrClientMsg): void;
    req(filters: NostrFilter[], opts?: {
        signal?: AbortSignal;
    }): AsyncGenerator<NostrRelayEVENT | NostrRelayEOSE | NostrRelayCLOSED>;
    query(filters: NostrFilter[], opts?: {
        signal?: AbortSignal;
    }): Promise<NostrEvent[]>;
    event(event: NostrEvent, opts?: {
        signal?: AbortSignal;
    }): Promise<void>;
    count(filters: NostrFilter[], opts?: {
        signal?: AbortSignal;
    }): Promise<{
        count: number;
        approximate?: boolean;
    }>;
    /** Get a stream of EE events. */
    private on;
    /** Wait for a single EE event. */
    private once;
    protected abortError(): DOMException;
    /** Start the idle time if applicable. */
    private maybeStartIdleTimer;
    /** Stop the idle timer. */
    private stopIdleTimer;
    /** Make a new WebSocket, but only if it was closed by an idle timeout. */
    private wake;
    /**
     * Close the relay connection and prevent it from reconnecting.
     * After this you should dispose of the `NRelay1` instance and create a new one to connect again.
     */
    close(): Promise<void>;
    [Symbol.asyncDispose](): Promise<void>;
}
/** Native JSON primitive value, including objects and arrays. */
type JsonValue = {
    [key: string]: JsonValue | undefined;
} | JsonValue[] | string | number | boolean | null;
export {};
//# sourceMappingURL=NRelay1.d.ts.map