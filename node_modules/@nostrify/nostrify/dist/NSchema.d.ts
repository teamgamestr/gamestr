import { z } from "zod";
import type { NostrClientAUTH, NostrClientCLOSE, NostrClientCOUNT, NostrClientEVENT, NostrClientMsg, NostrClientREQ, NostrConnectRequest, NostrConnectResponse, NostrEvent, NostrFilter, NostrMetadata, NostrRelayAUTH, NostrRelayCLOSED, NostrRelayCOUNT, NostrRelayEOSE, NostrRelayEVENT, NostrRelayMsg, NostrRelayNOTICE, NostrRelayOK } from "@nostrify/types";
/**
 * A suite of [zod](https://github.com/colinhacks/zod) schemas for Nostr.
 *
 * ```ts
 * import { NSchema as n } from '@nostrify/nostrify';
 *
 * const event: NostrEvent = n.event().parse(eventData);
 * const metadata: NostrMetadata = n.json().pipe(n.metadata()).parse(event.content);
 * const msg: NostrRelayMsg = n.relayMsg().parse(e.data);
 * const nsec: `nsec1${string}` = n.bech32('nsec').parse(token);
 * ```
 */
declare class NSchema {
    /** Schema to validate Nostr hex IDs such as event IDs and pubkeys. */
    static id(): z.ZodString;
    /** Nostr event schema. */
    static event(): z.ZodType<NostrEvent>;
    /** Nostr filter schema. */
    static filter(): z.ZodType<NostrFilter>;
    /**
     * Bech32 string.
     * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32
     */
    static bech32<P extends string>(prefix?: P): z.ZodType<`${P}1${string}`>;
    /** WebSocket URL starting with `ws://` or `wss://`. */
    static relayUrl(): z.ZodType<`ws://${string}` | `wss://${string}`>;
    /** NIP-01 `EVENT` message from client to relay. */
    static clientEVENT(): z.ZodType<NostrClientEVENT>;
    /** NIP-01 `REQ` message from client to relay. */
    static clientREQ(): z.ZodType<NostrClientREQ>;
    /** NIP-45 `COUNT` message from client to relay. */
    static clientCOUNT(): z.ZodType<NostrClientCOUNT>;
    /** NIP-01 `CLOSE` message from client to relay. */
    static clientCLOSE(): z.ZodType<NostrClientCLOSE>;
    /** NIP-42 `AUTH` message from client to relay. */
    static clientAUTH(): z.ZodType<NostrClientAUTH>;
    /** NIP-01 message from client to relay. */
    static clientMsg(): z.ZodType<NostrClientMsg>;
    /** NIP-01 `EVENT` message from relay to client. */
    static relayEVENT(): z.ZodType<NostrRelayEVENT>;
    /** NIP-01 `OK` message from relay to client. */
    static relayOK(): z.ZodType<NostrRelayOK>;
    /** NIP-01 `EOSE` message from relay to client. */
    static relayEOSE(): z.ZodType<NostrRelayEOSE>;
    /** NIP-01 `NOTICE` message from relay to client. */
    static relayNOTICE(): z.ZodType<NostrRelayNOTICE>;
    /** NIP-01 `CLOSED` message from relay to client. */
    static relayCLOSED(): z.ZodType<NostrRelayCLOSED>;
    /** NIP-42 `AUTH` message from relay to client. */
    static relayAUTH(): z.ZodType<NostrRelayAUTH>;
    /** NIP-45 `COUNT` message from relay to client. */
    static relayCOUNT(): z.ZodType<NostrRelayCOUNT>;
    /** NIP-01 message from relay to client. */
    static relayMsg(): z.ZodType<NostrRelayMsg>;
    /** Kind 0 content schema. */
    static metadata(): z.ZodType<NostrMetadata>;
    /** NIP-46 request content schema. */
    static connectRequest(): z.ZodType<NostrConnectRequest>;
    /** NIP-46 response content schema. */
    static connectResponse(): z.ZodType<NostrConnectResponse>;
    /**
     * Helper schema to parse a JSON string. It should then be piped into another schema. For example:
     *
     * ```ts
     * const event = NSchema.json().pipe(NSchema.event()).parse(data);
     * ```
     */
    static json(): z.ZodType<unknown>;
}
export { NSchema, z };
//# sourceMappingURL=NSchema.d.ts.map